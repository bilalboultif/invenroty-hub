<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Family Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
    <!-- Include Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <link href='https://fonts.googleapis.com/css?family=Libre Barcode 128' rel='stylesheet'>
    <script src="https://js.stripe.com/v3/"></script> <!-- Stripe.js for payment with card -->
    <script src="https://www.paypal.com/sdk/js?client-id=YOUR_PAYPAL_CLIENT_ID"></script> <!-- PayPal SDK -->
    <link rel="stylesheet" href="navbar.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="navbar.js" defer></script>
    <style>
    #barcode {
        font-family: 'Libre Barcode 128';font-size: 82px;
    }
     /* Global Reset */
     * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: #f4f7fa;
            color: #333333;
            padding: 20px;
        }
        body table {
            color: #33333300;
        }

        h1, h2 {
            color: #2c3e50;
            margin-bottom: 20px;
        }

        p {
            margin-bottom: 15px;
        }

        /* Style for the status dot */
.status-dotA {
    display: inline-block;
    width: 20px;
    height: 20px;
    border-radius: 50%;  /* Makes it a circle */
    margin-right: 10px;  /* Space between the dot and the username */
    vertical-align: middle;  /* Align the dot vertically with the text */
}

button {
  background-color: #000;
  color: white;
  border: none;
  padding: 10px 20px;
  margin: 10px;
  border-radius: 10px;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease-in-out;
}

        button:hover {
            background-color: #2980b9;
            transform: translateY(-3px);
        }

        button:active {
            transform: translateY(1px);
        }

        button:focus {
            outline: none;
        }

        h3 {
    margin: 10px 0;
}

h4 {
    margin-top: 5px;
    font-weight: normal;
    color: gray;
}
button.hidden {
    display: none;
}
/* Hide the image when clicked */
#icon-container.hidden {
    display: none;
}

/* Container to hold both local and remote videos */
.video-container {
    display: flex;
  gap: 20px;
  margin-top: 30px;
  position: fixed;
  top: -20px;
  left: -50px;
}

.video#my-video-container {
    width: 100px;
    height: 101px;
    margin-top: 10px;
    margin-left: 350px;
    z-index: 1;
    position: fixed;
    top: 20px;
    left: -70px;
    z-index: 111;
}
/* Style for individual video containers */
.video {
    width: 350px;
    height: 600px;
    background-color: #eee;
    border-radius: 12px;
    box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    margin-left: 100px;
}

/* Placeholder text */
.video-placeholder {
    font-size: 50px;
    color: #bbb;
}

/* Video element - making them fill the container */
.video video {
    width: 100%;
    height: 100%;
    border-radius: 12px;
    object-fit: cover;
}

/* Fullscreen button styling */
.fullscreen-icon {
    position: absolute;
  top: 10px;
  left: 100px;
  background-color: transparent;
  border: none;
  font-size: 24px;
  color: #333;
  cursor: pointer;
  z-index: 1000;
  transition: transform 0.2s ease-in-out;
}

/* Hover effect for fullscreen button */
.fullscreen-icon:hover {
    transform: scale(1.2);
    color: #4CAF50;
}

/* Fullscreen styles when in fullscreen mode */
.video-container.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%; /* Take full width of the viewport */
    height: 100vh; /* Take full height of the viewport */
    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0;
}

/* Fullscreen remote video (full screen on the body) */
.video#remote-video-container.fullscreen {
    width: 100vw; /* Remote video takes full width */
    height: 100vh; /* Remote video takes full height */
    max-width: none;
    max-height: none;
    z-index: 1; /* Ensure it's on top */
}

/* Small local video in fullscreen mode */
.video#my-video-container.fullscreen {
    width: 20vw;  /* 20% of the screen width */
    height: 20vh; /* 20% of the screen height */
    top: 10px;   /* Position it in a corner */
    left: 10px;  /* Position it in a corner */
    z-index: 999; /* Ensure it stays above other elements */
}



        .call-button {
            margin-top: 20px;
            text-align: center;
        }

        .call-button button {
            width: 200px;
            background-color: #e74c3c;
            margin-top: 10px;
        }

        .call-button button:hover {
            background-color: #c0392b;
        }

        /* Client and Admin Section */
        #clientsList {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }

        #clientsList li {
            background-color: #fff;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #clientsList li:hover {
            transform: scale(1.05);
            box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.15);
        }

        /* Main status dot */
.status-dot {
    width: 15px;
  height: 15px;
  border-radius: 50%;
  background-color: grey;
  border: 2px solid white;
  bottom: 0;
  right: 0;
  position: absolute;
  margin-right: 7px;
}
#img {
  height: 100%;
  width: 100%;
  border-radius: 50%;
}
#icon-container {
  width: 50px;
  height: 50px;
  position: relative;
}
/* Status dot animation */
.status-dot.online {
    background-color: #2ecc71; /* Green for online */
    animation: pulse 1.5s infinite; /* Subtle pulsing animation */
}

.status-dot.offline {
    background-color: #e74c3c; /* Red for offline */
    animation: none; /* No animation when offline */
}

.status-dot.away {
    background-color: #f39c12; /* Yellow for away */
    animation: pulse 1.5s infinite; /* Subtle pulsing animation */
}

.status-dot.busy {
    background-color: #2b942b; /* Orange for busy */
    animation: pulse 1.5s infinite; /* Subtle pulsing animation */
}

/* Pulse Animation */
@keyframes pulse {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.7;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

/* Hover effect */
.status-dot:hover {
    transform: scale(1.2); /* Slight zoom effect on hover */
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15); /* Glow effect */
}


       /* General Map Styling for Both Maps */
#mymap {
    width: 100%;
    height: 400px;
    margin-top: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Styling for 'mymap' (Always visible map under the table) */
#mymap {
    display: block; /* Always displayed */
}

        /* Map */
        #map {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 100%;
            height: 400px;
            border-radius: 12px;
            box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.5s ease;
            opacity: 0;
            visibility: hidden;
        }

        #map.visible {
            opacity: 1;
            visibility: visible;
        }

   

        /* Toggle Map */
        #toggle-map {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            background-color: #2ecc71;
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }

        #toggle-map:hover {
            background-color: #27ae60;
            transform: translateY(-5px);
        }

        /* Call in Progress */
        #callInProgress {
            display: flex;
            justify-content: center;
            gap: 20px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.1);
        }

        #callInProgress button {
            background-color: #e74c3c;
        }

        #callInProgress button:hover {
            background-color: #c0392b;
        }

        /* Mute / End Call Buttons */
        #muteButton, #endCallButton {
            width: 120px;
            padding: 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e74c3c;
            color: white;
            font-size: 18px;
            transition: transform 0.3s ease, background-color 0.3s ease;
        }

        #muteButton:hover, #endCallButton:hover {
            background-color: #c0392b;
            transform: scale(1.1);
        }

        /* Form and Inputs */
        input, select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ccc;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            border-color: #3498db;
            outline: none;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 14px;
            color: #7f8c8d;
        }

        /* Keyframe Animation for Wave Effect */
        @keyframes wave {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }

        .wave {
            display: inline-block;
            animation: wave 1s ease-in-out infinite;
        }

        .wave:nth-child(1) {
            animation-delay: 0s;
        }

        .wave:nth-child(2) {
            animation-delay: 0.2s;
        }

        .wave:nth-child(3) {
            animation-delay: 0.4s;
        }

        /* Modern Table Style */
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    overflow: hidden;
}

th, td {
    padding: 12px 20px;
    text-align: left;
    font-size: 16px;
    color: #333;
    transition: background-color 0.3s ease, transform 0.2s ease;
}

th {
    background-color: #3498db;
    color: white;
    font-weight: 600;
}

td {
    background-color: #f9f9f9;
    border-bottom: 1px solid #ddd;
}

tr:nth-child(even) td {
    background-color: #f2f2f2;
}

/* Hover Effect for Rows */
tr:hover {
    background-color: #f1f1f1;
    transform: scale(1.02);
}

/* Add a soft border when hovering over cells */
td:hover, th:hover {
    background-color: #f0f0f0;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
}

/* Add a subtle shadow for the table */
table {
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
}

/* Alternate Row Hover Effect */
tr:nth-child(even):hover td {
    background-color: #e3f2fd;
}

/* Responsive Design */
@media (max-width: 768px) {
    table {
        width: 100%;
        font-size: 14px;
    }
    th, td {
        padding: 10px;
    }
}

/* Styling for the table container */
.table-container {
    overflow-x: auto;
    padding: 20px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Smooth Border Radius on Hover for the entire table */
table {
    transition: border-radius 0.3s ease;
}

table:hover {
    border-radius: 15px;
}

/* Header Sticky Effect */
thead {
    position: sticky;
    top: 0;
    background-color: #3498db;
    z-index: 1;
}


label {
    display: inline-flex;
    align-items: center;
    cursor: pointer;
    font-size: 16px;
}

input[type="checkbox"] {
    margin-left: 8px;
    cursor: pointer;
}


/* Optional: Style for better layout */
.client-details {
    margin-top: 10px;
    padding-left: 20px;
}

.toggle-details-btn {
    margin-top: 10px;
    padding: 5px 10px;
    background-color: #007bff;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 14px;
}

.toggle-details-btn:hover {
    background-color: #0056b3;
}

.edit-button {
    margin-top: 10px;
    padding: 5px 10px;
    background-color: #28a745;
    color: white;
    border: none;
    cursor: pointer;
}

.edit-button:hover {
    background-color: #218838;
}






/* Fullscreen button styling */

/* Simple CSS for the modal */
#add-client-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: none;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background-color: white;
  padding: 20px;
  border-radius: 10px;
}

/* Basic Table Styling */
#groups-table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

#groups-table th, #groups-table td {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: center;
}

#groups-table th {
  background-color: #4e2f2f;
}

#groups-table td {
  vertical-align: middle;
}

/* Header Row: Full Width */
#groups-table thead tr th {
  text-align: center;
  background-color: #000000;
  width: 33%; /* Ensure the columns take up equal width */
}

/* Group Name Row Styling */
#groups-table td[colspan="2"] {
  text-align: left;
  font-weight: bold;
  background-color: #f9f9f9;
  font-size: 1.2em;
}

/* Add New Client Button */
#groups-table td button {
  padding: 6px 12px;
  background-color: #4CAF50;
  color: white;
  border: none;
  cursor: pointer;
}

#groups-table td button:hover {
  background-color: #45a049;
}

/* Styling for Empty Client Cell */
#groups-table td:first-child {
  background-color: #f9f9f9;
}

/* Client Rows */
#groups-table td:nth-child(2) {
 
  font-weight: normal;
}

/* Action Buttons Styling */
#groups-table td button {
  margin-right: 5px;
  background-color: #008CBA;
  color: white;
  border: none;
  cursor: pointer;
}

#groups-table td button:hover {
  background-color: #007bb5;
}

/* Ensure Client Name Spans 2 Columns */
#groups-table td[colspan="2"] {
  text-align: left;
  font-weight: normal;
}
/* Target buttons inside #groups-table */
#groups-table button {
    padding: 8px 14px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.2s ease, background-color 0.3s ease;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
    background-color: #3498db;
    color: white;
    margin: 0;  /* Adjust margin to avoid large spaces */
}

/* Optional: Add hover and active state for button interactions */
#groups-table button:hover {
    background-color: #2980b9;
    transform: scale(1.05);  /* Slightly enlarge the button on hover */
}

#groups-table button:active {
    background-color: #1f5d7a;
    transform: scale(0.95);  /* Slightly shrink the button on active click */
}


  /* Default Styles - For Laptops (default for larger screens) */
#chat-container {
    display: none; /* Initially hidden */
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 400px;
    height: 800px;
    background-color: #fff;
    border: 1px solid #ccc;
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
    border-radius: 10px;
    padding: 10px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
}
.mention-dropdown {
    position: absolute;
    z-index: 1000;
    background-color: white;
    border: 1px solid #ddd;
    max-height: 150px;
    overflow-y: auto;
    width: 200px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

.mention-dropdown li {
    padding: 8px;
    cursor: pointer;
}

.mention-dropdown li:hover {
    background-color: #f0f0f0;
}



#toggle-chat-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #2678ccd1;
    color: white;
    border: none;
    border-radius: 50%;
    padding: 15px;
    font-size: 24px;
    cursor: pointer;
    z-index: 10000;
}

/* Media Query for Phones (up to 768px) */
@media (max-width: 768px) {
    #chat-container {
        display: none; /* Initially hidden */
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 380px;
        height: 700px;
        background-color: #fff;
        border: 1px solid #ccc;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
        border-radius: 10px;
        padding: 10px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        margin-bottom: 20px;
    }

    #toggle-chat-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #2678ccd1;
        color: white;
        border: none;
        border-radius: 50%;
        padding: 15px;
        font-size: 24px;
        cursor: pointer;
        z-index: 10000;
    }
}

        
/* Styling the red color for the mention count */
#mentionCount {
    position: absolute;
    top: -5px;
    right: -5px;
    font-size: 12px;
    color: red;
    background-color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    box-shadow: 0 0 3px rgba(0, 0, 0, 0.1); /* Optional: small shadow for better visibility */
}

/* Optionally, you can add styles for the icon or button itself */
.material-icons {
    font-size: 24px;
}

/* Ensure the icon image doesn't change its size */
.material-icons img {
    width: 30px;
    height: 30px;
    margin-bottom: -10px;
}
        /* User list (if needed) */
        .user-list {
            padding: 10px;
            background-color: #f7f7f7;
            border-bottom: 1px solid #ddd;
        }

        /* Message List */
        .message-list {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            max-height: 600px;  /* Set max height to 300px to show 5 messages */
            margin-bottom: 10px;
        }



.reply-count {
    color: #007bff;  /* Blue color for the reply count */
    cursor: pointer; /* Change cursor to pointer for clickable reply count */
    margin-top: 5px;
}

.replies-container {
    margin-top: 10px;
    padding-left: 20px;
}
.reply-btn {
    align-self: flex-end; /* Position the button at the end of the message */
    padding: 0;;
    font-size: 12px;
    background-color: #007bff00;
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    margin-top: -25px;
}

.reply-btn:hover {
    background-color: #84898f; /* Darker blue when hovered */
}
.reply {
    margin-bottom: 5px;
}

.reply-header {
    font-weight: bold;
}

.reply-time {
    font-size: 0.75em;
    color: #888;
}


.message-header {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

.user-image {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    margin-right: 10px;
}

        .username {
            font-weight: bold;
        }

        .message-content {
            margin-top: 5px;
        }

        .message-input {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #f7f7f7;
            border-top: 1px solid #ddd;
        }

        .message-input input {
            flex: 1;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }

        .message-input button {
            padding: 10px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
        }

        /* Room Selection Styling */
        .select-container {
            padding: 10px;
            background-color: #f7f7f7;
            border-top: 1px solid #ddd;
        }
        /* Style the user list container */
      /* Styling for the user list */
        .user-list {
            display: flex;  
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding: 10px;
            background-color: #f7f7f7;
            border-bottom: 1px solid #ddd;
            max-width: 100%;
            scrollbar-width: thin;
        }

        .user-list::-webkit-scrollbar {
            height: 8px;
        }

        .user-list::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        .user-list::-webkit-scrollbar-track {
            background: transparent;
        }

        #userList {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
        }

        #userList li {
            display: inline-block;
            margin-right: 20px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            flex-shrink: 0;
            text-align: center;
            padding: 5px;
        }

        #userList li:hover {
            color: #007BFF;
            cursor: pointer;
        }

        .scroll-buttons {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        .scroll-buttons button {
            padding: 5px 10px;
            font-size: 16px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
        }
/* Typing indicator style */
.typing-indicator {
    font-size: 10px;
    color: #666;
    display: inline-block;
    margin-top: 10px;
}

/* Style for messages where the logged-in user is mentioned */
.mentioned-message {
    background-color: #5cc3f459; /* Highlight background with yellow */
    border-radius: 5px;
    padding: 5px;
    margin-bottom: 10px; /* Adds space between messages */
}


#dots {
    display: inline-block;
    font-size: 10px;
    margin-left: 2px;
    position: relative;
}

.dot {
    display: inline-block;
    width: 2px;
    height: 2px;
    margin-right: 2px;
    background-color: #666;
    border-radius: 50%;
    opacity: 0;
    animation: wave 1.5s infinite ease-in-out;
}

/* Create the wave effect */
@keyframes wave {
    0%, 100% {
        opacity: 0;
        transform: scale(0.8);
    }
    50% {
        opacity: 1;
        transform: scale(1.2);
    }
}

/* Delay each dot's animation to create the wave effect */
.dot:nth-child(1) {
    animation-delay: 0s;
}

.dot:nth-child(2) {
    animation-delay: 0.2s;
}

.dot:nth-child(3) {
    animation-delay: 0.4s;
}

/* Optional: Style the message text */
#typingMessage {
    font-weight: bold;
}

#mentionDropdown {
    max-height: 150px;
    overflow-y: auto;
    width: 200px;
    border-radius: 5px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    background-color: white;
    z-index: 1000; /* Ensure it's on top of other elements */
    position: absolute; /* Position it under the input field */
}

#mentionDropdown li {
    padding: 8px;
    cursor: pointer;
}

#mentionDropdown li:hover {
    background-color: #f0f0f0;
}

.system-message .message-content {
    font-style: italic;
    color: #888;  /* Lighter color for system messages */
    text-align: center;
    padding: 10px;
}
.message .message-header {
    display: flex;
    align-items: center;
}
.message {
    display: flex;
    flex-direction: column;
    margin-bottom: 10px;
    border-radius: 5px;
    padding-bottom: 5px;
}
.message .username {
    font-weight: bold;
}

.message .user-image {
  width: 35px;
    height: 35px;
    border-radius: 50%;
    margin-right: 10px;
    box-shadow: 2px 2px 1px gray;
}
/* Logout Button with Icon */
#logoutButton {
  position: fixed;
  top: 0px;
  right: 0px;
  background-color: #13a137;
  color: white;
  border: none;
  padding: 10px;
  border-radius: 50%;
  font-size: 1.5rem;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color 0.3s ease, transform 0.3s ease;
  z-index: 11110;
}

#logoutButton i {
  font-size: 1.5rem; /* Adjust icon size */
}

#logoutButton:hover {
  background-color: #ff4e50;
  transform: scale(1.1);
}

#logoutButton:focus {
  outline: none;
}
/* Style for the refresh button */
#refreshButton {
   position: fixed;
  top: 0px;
  left:  0px;
  background-color: #eddede; /* Transparent background */
   border: none;
  padding: 10px;
  border-radius: 50%;
  font-size: 1.5rem;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color 0.3s ease, transform 0.3s ease;
  z-index: 11110;
}

#refreshButton:hover {
  transform: scale(1.2); /* Slightly increase the size on hover */
  color: #4CAF50; /* Change color on hover */
}
 /* Navbar Styling */
  nav {
      background-color: #333;
      padding: 10px 0;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1111;
    }

    nav .nav-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      text-align: center;
      display: flex;
    }

    nav ul li {
      margin: 0 20px;
    }

    nav ul li a {
      color: white;
      text-decoration: none;
      padding: 10px 20px;
      font-size: 18px;
      display: inline-block;
      border-radius: 4px;
      transition: background-color 0.3s ease, transform 0.3s ease, color 0.3s ease;
    }

    /* Navbar links hover effects */
    nav ul li a:hover {
      background-color: #575757;
      color: #fff;
      transform: translateY(-2px);
    }

    /* Active link effect */
    nav ul li a.active {
      background-color: #444;
      color: #ffcc00;
      transform: translateY(-2px);
    }

    /* Responsive Design */
    @media screen and (max-width: 600px) {
      nav ul {
        display: none;
        flex-direction: column;
        position: absolute;
        top: 100%;
        left: 0;
        width: 100%;
        background-color: #333;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      nav ul li {
        margin: 10px 0;
      }

      nav .menu-toggle {
        display: block;
        color: white;
        cursor: pointer;
        padding: 10px;
        margin-top: -8px;
      }
      #refreshButton {
        left: 80px;
      }
     
    }

    /* Animation for links */
    @keyframes fadeInUp {
      0% {
        opacity: 0;
        transform: translateY(20px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    nav ul li a {
      animation: fadeInUp 0.6s ease-out forwards;
    }

    /* Staggered Animation Delays */
    nav ul li a:nth-child(1) {
      animation-delay: 0.1s;
    }

    nav ul li a:nth-child(2) {
      animation-delay: 0.2s;
    }

    nav ul li a:nth-child(3) {
      animation-delay: 0.3s;
    }


    #group-tools.hidden {
    display: none;
}
/* Room List: Display rooms in a horizontal row */
.room-listA {
    display: flex;
    transition: transform 0.5s ease-in-out; /* Smooth transition for sliding */
    overflow: hidden; /* Hide overflow to create sliding effect */
}

/* Each Room Item */
.room-item {
    flex: 0 0 20%; /* Show 5 rooms at a time */
    box-sizing: border-box;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    padding: 20px;
    transition: transform 0.2s ease-in-out;
    cursor: pointer;
    margin-right: 10px;
}

.room-item:hover {
    transform: scale(1.05); /* Slight zoom effect on hover */
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}

/* Arrows for Sliding */
.slide-left, .slide-right {
    position: absolute;
   
    margin-top: -150px;
    background-color: rgba(0, 0, 0, 0.5);
    color: #fff;
    border: none;
    font-size: 2em;
    padding: 10px;
    cursor: pointer;
    z-index: 10;
    transition: background-color 0.3s ease;
}

.slide-left {
    left: 10px;
}

.slide-right {
    right: 10px;
}

/* Hover effect for the arrows */
.slide-left:hover, .slide-right:hover {
    background-color: rgba(0, 0, 0, 0.8);
}

/* Responsiveness for smaller screens */
@media (max-width: 768px) {
    .room-item {
        flex: 0 0 45%; /* Show 2-3 rooms at a time */
    }
}

@media (max-width: 480px) {
    .room-item {
        flex: 0 0 90%; /* Show 1 room at a time */
    }

    .slide-left, .slide-right {
        font-size: 1.5em;
    }
}

/* Styling for the Room Card (Inside each room item) */
.room-card {
    padding: 10px;
}

.room-card h3 {
    margin: 0;
    font-size: 1.2em;
    color: #333;
}

.room-card p {
    margin: 8px 0;
    color: #666;
}

.room-card input[type="checkbox"] {
    margin-top: 10px;
}

/* Date Picker Styles */
input[type="date"] {
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #ddd;
    margin-bottom: 15px;
    font-size: 1rem;
    width: 100%;
    transition: border-color 0.3s ease;
}

/* Date Picker Focus */
input[type="date"]:focus {
    border-color: #4CAF50;
    outline: none;
}

/* Total Amount Display */
#total-amount {
    font-size: 1.3rem;
    font-weight: bold;
    color: #4CAF50;
    margin-bottom: 20px;
    text-align: center;
}

/* Checkout Button */
#checkout-btn {
    background-color: #4CAF50;
    color: #fff;
    padding: 15px 30px;
    border: none;
    border-radius: 5px;
    font-size: 1.2rem;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.3s ease;
    margin-bottom: 20px;
}

/* Hover effect on Checkout Button */
#checkout-btn:hover {
    background-color: #45a049;
}

/* Payment Section Styles */
#payment-section {
    margin-top: 30px;
    background-color: #fff;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Payment Form Section */
#payment-form {
    display: flex;
    flex-direction: column;
}

/* Payment Method Selection */
#payment-form input[type="radio"] {
    margin-right: 10px;
    margin-bottom: 15px;
    cursor: pointer;
}

/* Payment Method Label */
#payment-form label {
    font-size: 1.1rem;
    color: #333;
}

/* Card Payment Section */
#card-section {
    display: none;
}

/* Cash Payment Section */
#pay-cash {
    display: none;
}

/* Submit Button in Payment Form */
#payment-form button {
    background-color: #4CAF50;
    color: white;
    padding: 12px 25px;
    border: none;
    border-radius: 5px;
    font-size: 1rem;
    cursor: pointer;
    margin-top: 20px;
    transition: background-color 0.3s ease;
}

/* Hover effect on Submit Button */
#payment-form button:hover {
    background-color: #45a049;
}

/* Transition for smooth display of payment sections */
#payment-form > div {
    transition: opacity 0.3s ease, max-height 0.3s ease;
    overflow: hidden;
}

/* Media Query for Mobile Devices */
@media screen and (max-width: 768px) {
    h1 {
        font-size: 2rem;
    }

    .room-card {
        padding: 15px;
    }

    #checkout-btn {
        font-size: 1rem;
        padding: 12px 25px;
    }

    input[type="date"] {
        font-size: 0.9rem;
    }
}


    </style>
</head>
<body>
    <nav>
        <div class="nav-container">
            <div class="menu-toggle">
                <i class="fas fa-bars"></i>
            </div>
            <ul>
                <li><a href="client-dashboard.html">Home</a></li>
                <li><a href="clientWalkToMasjid.html">Macca Map</a></li>
                <li><a href="clientWalkToMasjid2.html">Medina Map</a></li>
            </ul>
        </div>
      </nav>
    <button id="logoutButton" onclick="logout()"">
        <i class="fas fa-sign-out-alt"></i> <!-- Font Awesome logout icon -->
      </button>
      <button id="refreshButton" class="refresh-icon">
        <i class="fas fa-sync-alt"></i> <!-- Font Awesome refresh icon -->
      </button>
    <div id="home">
        
        <h1 style="
        margin-top: 50px;
        background: rgba(0, 0, 0, 0.1);
        width: 110%;
        padding: 20px 60px;
        margin-left: -20px;
    ">Welcome, <span id="adminName"></span> - Family Tracker</h1>
        <h2>Admin Dashboard</h2>
        <p>Here, you can manage family members and track their location.</p>
        <p>Email: <span id="adminEmail"></span></p>
        <p>Phone Number: <span id="adminPhoneNumber"></span></p>
        <p>Age: <span id="adminAge"></span></p>
        <button id="clearAlertsBtn">Clear Alerts</button>
        <div id="client-status-list">
            <!-- Client statuses will be dynamically added here -->
        </div>
      

        <button id="toggleClientLogTools">Client Log Tools</button>

<!-- Client log tools section -->
<div id="clientLogTools" style="display: none;">
    <h2>Client Location Logs</h2>
    
    <!-- Filter form to fetch logs based on time range and security code -->
    <form id="filter-form">
        <label for="startTime">Start Time:</label>
        <input type="datetime-local" id="startTime" required>
    
        <label for="endTime">End Time:</label>
        <input type="datetime-local" id="endTime" required>
    
        <label for="securityCode">Enter Security Code:</label>
        <input type="text" id="securityCode" placeholder="Enter Client's Security Code" required>
    
        <button type="submit">Get Client Location Logs</button>
    </form>
    
    <!-- Table to display location logs -->
    <table border="1">
        <thead>
            <tr>
                <th>Time</th>
                <th>Latitude</th>
                <th>Longitude</th>
                <th>Alert Type</th>
            </tr>
        </thead>
        <tbody id="tableBody">
            <!-- Location logs will be inserted here -->
        </tbody>
    </table>
    
    <!-- Map container for location display -->
    
    
    <!-- Time Display for the client's movement -->
    <div id="timeDisplay" style="font-size: 18px; margin-top: 20px;"></div>
    
    <!-- Play Button to simulate tracking on the map -->
    <button id="playButton">Play Track</button>
</div>

        
       

        <div id="mymap"></div>
<!-- Input fields for geofence radius -->
<button id="toggleLocationTools">Location Tools</button>

<!-- Location tools section -->
<div id="locationTools" style="display: none;">
    <label for="radius">Geofence Radius (meters):</label>
    <input type="number" id="radius" value="100" min="10" max="1000" step="10">
    <button id="setGeofence" onclick="setGeofence()">Set Geofence</button>

    <!-- Stop Geofence Button -->
    <button id="stopGeofence">Stop Geofence</button>

    <div id="alert-container" style="display: none;">
        <div id="alert-message">
            <!-- The message will be dynamically inserted here -->
        </div>
        <button id="found-button" onclick="clearGeofenceAlert()">Found</button>
        <button id="not-yet-button" onclick="keepAlert()">Not Yet</button>
    </div>
<button id="safeLocationBtn">Set Safe Location</button>
    <button id="sendSafeLocationBtn" style="display:none;" >Send Safe Location</button>

</div>
    
<h2>Clients</h2>
      
<button id="toggleClientList">List Of Clients</button>
<ul id="clientsList" style="display: none;"></ul>  <!-- Initially hidden -->

        <div class="video-container" id="video-call-container" style="display: none;"> 
            <button id="fullscreenButton" class="fullscreen-icon">
                    <i class="fas fa-expand"></i> <!-- Fullscreen icon -->
                </button>
            <div class="video" id="my-video-container">
                <!-- Fullscreen Button (in local video container) -->
               
                
                <!-- Local Video Placeholder -->
                <div id="local-video-placeholder" class="video-placeholder">
                    <span id="video-icon" style="font-size: 100px; color: #ccc;"></span>
                </div>
                
                <!-- Actual Local Video (hidden by default) -->
                <video id="my-video" playsinline muted autoplay></video>
            </div>
        
            <div class="video" id="remote-video-container">
                <!-- Remote Video -->
                <video id="user-video" playsinline autoplay></video>
            </div>
        </div>
        <!-- Form to update client info (initially hidden) -->
<form id="updateClientForm" style="display:none;">
    <label for="gender">Gender:</label>
    <select id="gender" name="gender">
        <option value="male">Male</option>
        <option value="female">Female</option>
        <option value="other">Other</option>
    </select>
    <br>

    <label for="firstName">First Name:</label>
    <input type="text" id="firstName" name="firstName" placeholder="Enter first name">
    <br>

    <label for="lastName">Last Name:</label>
    <input type="text" id="lastName" name="lastName" placeholder="Enter last name">
    <br>

    <button type="submit">Update Client Info</button>
</form>


        <div class="myId" style="display: none;">
            <label for="name">Name:</label>
            <input type="text" id="name" placeholder="Enter your name" style="margin-bottom: 20px;">
            <button id="copy-id" onclick="copyToClipboard()" style="margin-bottom: 2rem;">Copy ID</button>
            
            <input type="text" id="idToCall" placeholder="ID to call">
            <div class="call-button">
                <button id="start-call" onclick="startCalla()">Start Call</button>
            </div>
        </div>

        <!-- Caller Container (Displays when someone is calling) -->
        <div id="caller-container" style="display: none;">
            <h1 id="caller-name"></h1>
            <button id="answer-call" onclick="answerCall()">Answer</button>
        </div>

        <!-- After Call UI (Visible once the call is answered) -->
        <div id="after-answer" style="display: none;">
            <h2 id="you-live-with-name">You live with </h2>
            <div style="position: fixed;bottom: 150px;">
           <button id="mute-button" onclick="toggleMute()">Mute</button>
            <button id="camera-button" onclick="toggleCamera()">Turn Off Camera</button>
            <button id="end-call" onclick="endCall()">End Call</button>     
            </div>
            
        </div>
        <!-- Logout Button -->
        

    </div>
   

    <!-- Admin Actions -->
    <div class="admin-section">
       

        <!-- Audio Call to Client -->
   
        <input type="text" id="clientSecurityCode" placeholder="Enter Client's Security Code" style="display: none;">
        <button style="display: none;" id="callParent" onclick="startCall()">Call</button>
    </div>
    <h2 style="display: none;" id="callMessage">Initiate Call to Client</h2>
    <button style="display: none;" id="cancelCall">Cancel</button>
    <div id="callTimer" style="display: none;">00:00</div>

      <!-- Call in Progress Section (Visible only after accepting the call) -->
    <div id="callInProgress" style="display:none;">
   
      
        <div id="callTimer" style="display: none;">00:00</div>
        <button id="endCallButton">End</button>
        <button id="muteButton">Mute</button>
       
        <canvas id="soundWave" width="500" height="100"></canvas>
        <audio id="audioCall" controls style="display:none;">
            <source id="audioSource" type="audio/wav">
        </audio>
    </div>
    <h3 style="display: block;">Get Parent's Location</h3>
    <input style="display: block;" type="text" id="secretCodeInput" placeholder="Enter secret code" />
    <button style="display: block;" id="getParentLocationButton" onclick="getParentLocation(document.getElementById('secretCodeInput').value)">Location</button>
    
    <!-- Display Parent Location -->
    <div id="parentLocation" style="display:none;">
        <p>Latitude: <span id="latitude"></span></p>
        <p>Longitude: <span id="longitude"></span></p>
    </div>
    
    <h2 style="display: none;">Route to Parent</h2>
<p style="display: none;">Select your transport mode:</p>
<select style="display: none;" id="transportSelect">
    <option value="foot">Walking</option>
    <option value="car">Car</option>
    <option value="bike">Bicycle</option>
    <option value="bus">Public Transport</option>
</select>


<div id="theMap">
<div id="map" style="height: 400px; width: 600px;"></div> <!-- Map initially hidden -->
<div id="toggle-map" class="toggle-btn">
    <i class="fas fa-map-marker-alt"></i> <!-- Map icon (Font Awesome) -->
</div> 
</div>
<div id="updateTripInfoContainer"></div>

<form id="updateTripInfoForm" style="display:none;">
   
        <!-- Flight Info -->
        <label for="seat">Seat:</label>
        <input type="text" id="seat" name="seat"><br><br>
    
        <label for="flightNumber">Flight Number:</label>
        <input type="text" id="flightNumber" name="flightNumber"><br><br>
    
        <label for="airlineCompany">Airline Company:</label>
        <input type="text" id="airlineCompany" name="airlineCompany"><br><br>
    
        <!-- Hotel Info -->
        <label for="roomNumber">Room Number:</label>
        <input type="text" id="roomNumber" name="roomNumber"><br><br>
    
        <label for="hotelName">Hotel Name:</label>
        <input type="text" id="hotelName" name="hotelName"><br><br>
    
        <!-- Arafa and Mina Khayma -->
        <label for="arafaKhayma">Arafa Khayma:</label>
        <input type="text" id="arafaKhayma" name="arafaKhayma"><br><br>
    
        <label for="minaKhayma">Mina Khayma:</label>
        <input type="text" id="minaKhayma" name="minaKhayma"><br><br>
    
        <button type="submit">Update Trip Info</button>
    </form>
    

<!-- New Group Button -->
<button type="button" id="newGroupBtn">New Group</button>


<form id="create-group-form" style="display: none;">
  <button type="button" id="hideFormBtn">Hide Form</button>

  <label for="groupName">Group Name:</label>
  <input type="text" id="groupName" placeholder="Enter Group Name" required><br><br>

  <label for="securityCodes">Enter Client Security Codes (comma separated):</label>
  <input type="text" id="securityCodes" placeholder="Enter security codes" required><br><br>

  <label for="flightNumberC">Flight Number:</label>
  <input type="text" id="flightNumberC" placeholder="Flight Number" required><br><br>

  <label for="busDeparturePlaceC">Bus Departure Place:</label>
  <input type="text" id="busDeparturePlaceC" placeholder="Bus Departure Place" required><br><br>

  <label for="hotelNameC">Hotel Name:</label>
  <input type="text" id="hotelNameC" placeholder="Hotel Name" required><br><br>

  <label for="foodPlanC">Food Plan:</label>
  <input type="text" id="foodPlanC" placeholder="Food Plan" required><br><br>

  <button type="submit">Create Group</button>
</form>



<form id="update-trip-form" style="display: none;">
    <!-- Flight Info -->
    <label for="flightNumber">Flight Number:</label>
    <input type="text" id="flightNumber" required><br>

    <label for="departure">Departure (Date & Time):</label>
    <input type="datetime-local" id="departure" required><br>

    <label for="arrival">Arrival (Date & Time):</label>
    <input type="datetime-local" id="arrival" required><br>

    <label for="departureAirport">Departure Airport:</label>
    <input type="text" id="departureAirport" required><br>

    <label for="arrivalAirport">Arrival Airport:</label>
    <input type="text" id="arrivalAirport" required><br>

   

    <!-- Bus Info -->
    <label for="busDepartureTime">Bus Departure (Date & Time):</label>
    <input type="datetime-local" id="busDepartureTime" required><br>
    
    <label for="busDeparturePlace">Bus Departure Place:</label>
    <input type="text" id="busDeparturePlace" required><br>
    
    <label for="busDestination">Bus Destination:</label>
    <input type="text" id="busDestination" required><br>
    


    <!-- Hotel Info -->
    <label for="hotelName">Hotel Name:</label>
    <input type="text" id="hotelName" required><br>

   

    <label for="location">Hotel Location:</label>
    <input type="text" id="location" required><br>

    <label for="checkInTime">Hotel Check-In Time:</label>
    <input type="datetime-local" id="checkInTime" required><br>

    <label for="checkOutTime">Hotel Check-Out Time:</label>
    <input type="datetime-local" id="checkOutTime" required><br>

    <!-- Food Plan -->
    <label for="foodPlanDay">Food Plan Day:</label>
    <input type="text" id="foodPlanDay" required><br>

    <label for="foodPlanMeals">Meals (Format: Meal Type: Menu, one per line):</label>
    <textarea id="foodPlanMeals" rows="5" placeholder="Breakfast: Pancakes, Coffee&#10;Lunch: Chicken Salad&#10;Dinner: Grilled Salmon" required></textarea><br>

    <button type="submit">Update Trip</button>
</form>

<!-- Toggle button for Group Tools -->
<button id="toggle-group-tools-btn">Show Group Tools</button>

<div id="group-tools" style="display: none;">
    <h2>All Groups and Clients</h2>
    <input type="text" id="searchInput" placeholder="Search by username, clientId, or security code" />
    <table id="groups-table">
        <thead>
            <tr>
                <th>Clients</th>
                <th>Actions</th>
                <th>Haj Steps</th>
            </tr>
        </thead>
        <tbody>
            <!-- Dynamic content will be inserted here -->
        </tbody>
    </table>
    <div id="edit-group-form" style="display: none;">
        <h2>Edit Group Clients</h2>
        <label for="group-name">Group Name:</label>
        <input type="text" id="group-name" disabled>
        <br>
        <label for="client-select">Select Clients:</label>
        <select id="client-select" multiple>
            <!-- Dynamically filled with client options -->
        </select>
        <br>
        <button onclick="updateGroupClients()">Save Changes</button>
        <button onclick="document.getElementById('edit-group-form').style.display='none'">Cancel</button>
        <input type="hidden" id="group-id">
        
        <!-- Modal for moving clients -->
        <div id="move-client-modal" style="display: none;">
            <h3>Move Client to Another Group</h3>
            <form id="move-client-form">
              <label for="group-select">Select New Group:</label>
              <select id="group-select" required></select>
              <button type="submit">Move Client</button>
              <button type="button" onclick="closeMoveModal()">Cancel</button>
            </form>
        </div>

        <!-- Modal for client delete confirmation -->
        <div id="delete-client-modal" style="display: none;">
            <h3>Are you sure you want to delete this client from the group?</h3>
            <button id="delete-client-confirm">Yes</button>
            <button type="button" onclick="closeDeleteModal()">Cancel</button>
        </div>
    </div>

    <!-- Modal for Adding Clients -->
    <div id="add-client-modal" style="display:none;">
        <div class="modal-content">
            <h3>Add New Client(s)</h3>
            <label for="securityCodesA">Enter Security Codes (comma separated):</label>
            <input type="text" id="securityCodesA" placeholder="Security Codes" />
            <button onclick="addClientsToGroup()">Add Clients</button>
            <button onclick="closeModal()">Cancel</button>
        </div>
    </div>
</div>

  
 <!-- Chat -->
       <button id="toggle-chat-btn" onclick="toggleChat()">
        <span class="material-icons"><img src="img/chat.png" style="width: 30px; height: 30px; margin-bottom: -10px;"></span> <!-- Chat Icon -->
    </button>
  
    <!-- Chat Container -->
    <div id="chat-container" style="display: none;">
        <!-- User List -->
        <div class="user-list">
            <ul id="userList">
                <!-- Dynamic user list goes here -->
            </ul>
        </div>
        <div class="scroll-buttons">
            <button id="scroll-left">←</button>
            <button id="scroll-right">→</button>
        </div>
  
        <!-- Messages List -->
        <div class="message-list" id="messageList">
            <!-- Dynamic messages go here -->
        </div>
        <div id="typingIndicator" class="typing-indicator" style="display: none;">
          <!-- Initially, we'll just show the text; dots will be added via CSS animation -->
          <span id="typingMessage"></span>
          <span id="dots">
              <span class="dot"></span>
              <span class="dot"></span>
              <span class="dot"></span>
          </span>
      </div>
            <!-- Input Area -->
            <div class="message-input">
                <form id="chatForm">
                    <input type="text" id="inputMessage" placeholder="Type your message...">
                    <!-- Dropdown for showing mentions -->
      <ul id="mentionDropdown" style="display: none; position: absolute; list-style: none; background-color: white; border: 1px solid #ccc; padding: 0; margin: 0;">
        <!-- User list will be dynamically added here -->
      </ul>
                <button type="submit" id="sendButton">Send</button>
                <img src="https://icons.getbootstrap.com/assets/icons/emoji-smile.svg" id="emojiPicker" alt="emoji" style="cursor: pointer;">
                <div id="emojiPickerContainer" style="display:none;">
                    <div class="emoji" data-emoji="😊">😊</div>
                    <div class="emoji" data-emoji="😎">😎</div>
                    <div class="emoji" data-emoji="😂">😂</div>
                    <div class="emoji" data-emoji="🤖">🤖</div>
                    <!-- Add more emojis as needed -->
                </div>
                        </form>
        </div>
        <!-- Typing Indicator (Hidden by default) -->
  
  
  
        <!-- Room Selection -->
        <div class="select-container">
           <!-- Room Selection Dropdown -->
<select id="roomSelect" onchange="updateUserListForRoom(this.value)">
    <!-- Room options will be dynamically populated here -->
</select>

        </div>
    </div>

<!-- Create Room Button -->
<button type="button" id="create-room-btn">Create Room</button>

<!-- Room Creation Form -->
<form id="create-room-form" style="display: none;">
    <label for="hotelNameCreate">Hotel Name:</label>
    <input type="text" id="hotelNameCreate" name="hotelNameCreate" required><br><br>

    <label for="roomNumberCreate">Room Number:</label>
    <input type="text" id="roomNumberCreate" name="roomNumberCreate" required><br><br>

    <label for="roomType">Room Type:</label>
    <select id="roomType" name="roomType" required>
        <option value="single">Single</option>
        <option value="double">Double</option>
        <option value="suite">Suite</option>
    </select><br><br>

    <label for="bedNumber">Bed Number:</label>
    <input type="number" id="bedNumber" name="bedNumber" required><br><br>

    <label for="peopleInRoom">People in Room:</label>
    <input type="number" id="peopleInRoom" name="peopleInRoom" required><br><br>

    <label for="level">Room Level:</label>
    <input type="text" id="level" name="level" required><br><br>

    <label for="startDate">Start Date:</label>
    <input type="date" id="startDate" name="startDate" required><br><br>

    <label for="endDate">End Date:</label>
    <input type="date" id="endDate" name="endDate" required><br><br>

    <label for="hotelStar">Hotel Star Rating:</label>
    <input type="number" id="hotelStar" name="hotelStar" min="1" max="5" required><br><br>

    <h3>Clients in Room:</h3>
    <!-- Example dynamic client list -->
    <div id="clients-container">
        <label for="clientsForRoom">Select Clients:</label>
        <select id="clientsForRoom">
            <option value="" disabled selected>Select a client</option>
            <!-- Client options will be populated dynamically here -->
        </select>
        <button type="button" id="add-client-to-room-btn">Add Client</button>
    </div>
    <br>

   

    <button type="submit">Create Room</button>
</form>

</div>

<button id="room-list-btn">Display Rooms Table</button>
<div id="rooms-list" style="display: none;">
    <h2>All Rooms</h2>
    <input type="text" id="searchInputRoom" placeholder="Search by room number or client name" />

    <table id="rooms-table" >
        <thead>
            <tr>
                <th style="text-align: center;">Bed Number</th>
                <th style="text-align: center;">Bed Number</th>
                <th style="text-align: center;">Hotel Name</th>
                <th style="text-align: center;">Hotel Star</th>
                <th style="text-align: center;">Level</th>
                <th style="text-align: center;">update</th>
                <th style="text-align: center;">delete</th>
                <th style="text-align: center;">Clients</th>
            </tr>
        </thead>
        <tbody id="rooms-table-body">
            <!-- Room rows will be populated here -->
        </tbody>
    </table>
</div>

<div id="update-room-form" style="display:none;">
    <form id="update-room">
        <!-- Room details -->
        <label for="update-bedNumber">Bed Number:</label>
        <input type="number" id="update-bedNumber" name="bedNumber" required><br>

        <label for="update-hotelName">Hotel Name:</label>
        <input type="text" id="update-hotelName" name="hotelName" required><br>

        <label for="update-hotelStar">Hotel Star:</label>
        <input type="number" id="update-hotelStar" name="hotelStar" required><br>

        <label for="update-peopleInRoom">People in Room:</label>
        <input type="number" id="update-peopleInRoom" name="peopleInRoom" required><br>

        <label for="update-level">Level:</label>
        <input type="text" id="update-level" name="level" required><br>

        <label for="update-startDate">Start Date:</label>
        <input type="datetime-local" id="update-startDate" name="startDate" required><br>

        <label for="update-endDate">End Date:</label>
        <input type="datetime-local" id="update-endDate" name="endDate" required><br>

        <label for="update-roomType">Room Type:</label>
        <input type="text" id="update-roomType" name="roomType" required><br>

        <h3>Clients in Room</h3>
        <ul id="update-clients-list"></ul>

        <!-- Add Client Section -->
        <h3>Add New Client</h3>
        <select id="client-selector">
            <!-- Options will be dynamically populated with clients not in the room -->
        </select>
        <button type="button" id="add-client-button">Add Client</button><br><br>

        <button type="submit">Update Room</button>
    </form>
</div>

<h1>Available Rooms</h1>
<table id="rooms-table-hotel" style="margin-bottom: 50px;">
    <thead>
        <tr>
            <th style="text-align: center;">Room Number</th>
            <th style="text-align: center;">Bed Number</th>
            <th style="text-align: center;">Hotel Name</th>
            <th style="text-align: center;">Hotel Star</th>
            <th style="text-align: center;">Level</th>
            <th style="text-align: center;">Clients</th>
            <th style="text-align: center;">Actions</th>
        </tr>
    </thead>
    <tbody>
        <!-- Room rows will be populated here -->
    </tbody>
</table>


<h1>Available Rooms for Booking</h1>

<!-- Room List -->
<div class="room-slider-container">
    

    <!-- Room List: Display rooms in a horizontal row -->
    <div id="room-listA" class="room-listA">
        <!-- Room items will be appended here dynamically using JavaScript -->
    </div>
<button class="slide-left" onclick="slideRooms('left')">&#10094;</button>
    <button class="slide-right" onclick="slideRooms('right')">&#10095;</button>
</div>

<!-- Date pickers -->
<label for="start-date">Start Date</label>
<input type="date" id="start-date" required>

<label for="end-date">End Date</label>
<input type="date" id="end-date" required>

<!-- Total Amount Display -->
<p id="total-amount">Total: $0</p>

<!-- Checkout Button -->
<button id="checkout-btn">Proceed to Checkout</button>

<!-- Payment Section -->
<div id="payment-section" style="display:none;">
    <form id="payment-form">
        <input type="radio" name="payment-method" value="card" /> Pay with Card
        <input type="radio" name="payment-method" value="cash" checked /> Pay with Cash

        <div id="card-section" style="display:none;">
            <div id="card-element"></div>
        </div>

        <div id="pay-cash" style="display:none;">
            <p>Cash payment selected</p>
        </div>

        <button type="submit">Submit Payment</button>
    </form>
</div>
<!-- Success Message Placeholder -->
<div id="payment-success" style="display: none;">
    <h2>Payment Successful!</h2>
    <p>Your rooms have been reserved. Below are your booking details:</p>
    
    <div id="reserved-rooms-details"></div> <!-- Dynamic room details will go here -->
    <p id="total-payment"></p>
    <p>Start Date: <span id="start-date-display"></span></p>
    <p>End Date: <span id="end-date-display"></span></p>
</div>

<footer>
    Admin Dashboard - Family Tracker
</footer>

<script src="cordova.js"></script>
<script src="./hotel.js"></script>
    <!-- Leaflet JS for the map -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>  
    
    <!-- Leaflet Routing Machine for route plotting -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.10.0/simplepeer.min.js"></script>
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>  <!-- Socket.IO for real-time communication -->
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.0/dist/JsBarcode.all.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js"></script>

    <script src="cordova.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://js.stripe.com/v3/"></script> <!-- Stripe.js for payment with card -->

    <script>

        const backendURL = window.env.AUTH_API_URL
        let hajSteps = []; // This will store selected step numbers and completion status

  async function fetchClients() {
            const adminEmail = localStorage.getItem('email');

            try {
                const response = await fetch(`${backendURL}/admin/clients?adminEmail=` + encodeURIComponent(adminEmail));
                const data = await response.json();
                // console.log("fetchClients: ", data)
                if (data.success) {
                    return data.clients;  // Assuming this returns an array of clients with { _id, firstName, lastName, username }
                } else {
                    alert('Failed to fetch clients.');
                    return [];
                }
            } catch (error) {
                console.error('Error fetching clients:', error);
                alert('Error fetching clients.');
                return [];
            }
        }
let availableGroups = [];  // Declare a global variable for storing the groups
let groups = [];  // Global variable to store the groups
const groupId = localStorage.getItem('groupId')

async function fetchGroups() {
    try {
        const token = localStorage.getItem('token');  // Get the token from localStorage
        if (!token) {
            alert("You are not logged in.");
            return;
        }

        const response = await fetch(`${backendURL}/all-groups`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`  // Send the token in the Authorization header
            }
        });

        const data = await response.json();
        if (data.success) {
           
            // Get the admin ID from the token or session
            const adminId = localStorage.getItem('adminId');
            // Filter groups by adminId
            availableGroups = data.groups.filter(group => group.admin._id === adminId);
            // console.log("GROUP data fetch ", availableGroups);
            displayGroups(availableGroups);  // Call the function to display the filtered groups
        } else {
            alert('No groups found.');
        }
    } catch (error) {
        console.error('Error fetching groups:', error);
        alert('Error fetching groups.');
    }
}

// Flag to track if the displayGroups is being called multiple times
let isRendering = false;

// Function to filter clients based on the search input
const filterClients = (group, query, clientsData) => {
  if (!query) return group.clients;  // Return all clients if there's no search query

  return group.clients.filter(client => {
    const clientData = clientsData.find(c => c._id === client._id);
    console.log('data in filterClient: ', clientData)
    if (!clientData) return false;  // No client data found, skip this one

    // Check if username, clientId, or security code matches the query
    const usernameMatch = clientData.username && clientData.username.toLowerCase().includes(query.toLowerCase());
    const clientIdMatch = clientData._id && clientData._id.toLowerCase().includes(query.toLowerCase());
    const securityCodeMatch = clientData.securityCode && clientData.securityCode.toLowerCase().includes(query.toLowerCase());

    return usernameMatch || clientIdMatch || securityCodeMatch;
  });
};


async function displayGroups(groupsData, searchQuery = '') {
  // If rendering is already in progress, skip the rendering
  if (isRendering) {
    console.log("Skipping rendering because it's already in progress...");
    return; // Skip if rendering is in progress
  }

  // Set rendering flag to true
  isRendering = true;

  const tableBody = document.querySelector('#groups-table tbody');
  tableBody.innerHTML = '';  // Clear previous table content before rendering anything

 

  // Fetch clients data once
  const clientsData = await fetchClients();  // Get all clients for the admin
  console.log("ClientsData groups: ", clientsData);
  // Loop through each group
  groupsData.forEach(group => {
    const groupRow = document.createElement('tr');
    const groupNameCell = document.createElement('td');
    groupNameCell.textContent = group.groupName || 'No Group Name';  // Display the group name
    groupNameCell.colSpan = 3;  // Make the Group Name cell span across the entire row (3 columns in this case)
    groupRow.appendChild(groupNameCell);

    // Add "Add New Client" button next to the group name with icon
    const addClientButtonCell = document.createElement('td');
    const addClientButton = document.createElement('button');
    addClientButton.innerHTML = '<i class="fas fa-plus"></i>';  // Using + icon
    addClientButton.onclick = () => showAddClientModal(group._id);  // Show modal for adding new clients
    addClientButtonCell.appendChild(addClientButton);
    groupRow.appendChild(addClientButtonCell);

    // Add "Update Group" button with pen icon
    const updateGroupButtonCell = document.createElement('td');
    const updateGroupButton = document.createElement('button');
    updateGroupButton.innerHTML = '<i class="fas fa-pen"></i>';  // Using pen icon
    updateGroupButton.onclick = () => showUpdateGroupForm(group);  // Trigger the update form for this group
    updateGroupButtonCell.appendChild(updateGroupButton);
    groupRow.appendChild(updateGroupButtonCell);
    
    // Add "Delete Group" button with trash can icon
    const deleteGroupButtonCell = document.createElement('td');
    const deleteGroupButton = document.createElement('button');
    deleteGroupButton.innerHTML = '<i class="fas fa-trash"></i>';  // Using trash icon
    deleteGroupButton.onclick = () => deleteGroup(group._id);  // Trigger delete group function
    deleteGroupButtonCell.appendChild(deleteGroupButton);
    groupRow.appendChild(deleteGroupButtonCell);

     // Add "Haj Steps" button cell
     const updateTimeButtonCell = document.createElement('td');
            const updateTimeButton = document.createElement('button');
            updateTimeButton.textContent = 'Update Time';
            updateTimeButton.onclick = () => saveHajProgress(group._id);
            updateTimeButtonCell.appendChild(updateTimeButton);
            groupRow.appendChild(updateTimeButtonCell);

            const inputTimeCell = document.createElement('td');
            const inputTime = document.createElement('input');
            inputTime.type = 'datetime-local';
            inputTime.id = `hajStartTime-${group._id}`;
            if (group.hajStartTime) {
    const dt = new Date(group.hajStartTime);
    inputTime.value = dt.toISOString().slice(0, 16);
}
            inputTimeCell.appendChild(inputTime);
            groupRow.appendChild(inputTimeCell);

  // Function to save updated hajSteps and hajStartTime to backend
  async function saveHajProgress(groupId) {
    try {
        // Get the input value directly from the input element
        const startTimeInput = document.getElementById(`hajStartTime-${groupId}`).value;
        const hajStartTime = startTimeInput ? new Date(startTimeInput).toISOString() : null;
        
        console.log("Saving start time:", hajStartTime); // Debug log

        // First, get the current hajSteps
        const getResponse = await fetch(`${backendURL}/group-haj-steps/${groupId}`);
        const currentData = await getResponse.json();
        
        if (!currentData.success) {
            throw new Error('Failed to get current haj steps');
        }

        // Then update with the new time while preserving existing hajSteps
        const response = await fetch(`${backendURL}/group-haj-steps/${groupId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                hajSteps: currentData.hajSteps,
                hajStartTime: hajStartTime
            }),
        });
        const data = await response.json();

        if (data.success) {
            alert('تم حفظ وقت بداية الحج بنجاح');
        } else {
            alert('فشل في حفظ وقت بداية الحج');
        }
    } catch (error) {
        console.error('Error saving haj start time:', error);
        alert('حدث خطأ أثناء حفظ وقت بداية الحج');
    }
}

            const hajStepsButtonCell = document.createElement('td');
            const hajStepsButton = document.createElement('button');
            hajStepsButton.textContent = 'Haj Steps';
            hajStepsButton.onclick = () => openHajStepsModal(group._id);
            hajStepsButtonCell.appendChild(hajStepsButton);
            groupRow.appendChild(hajStepsButtonCell);

            tableBody.appendChild(groupRow);  // Add the group name row to the table
            addClientButton.title = "Add New Client";
            updateGroupButton.title = "Update Trip Information";
            deleteGroupButton.title = "Delete Group";
            hajStepsButton.title = "Manage Haj Steps";

    tableBody.appendChild(groupRow);  // Add the group name row to the table
    addClientButton.title = "Add New Client";
updateGroupButton.title = "Update Trip Information";
deleteGroupButton.title = "Delete Group";

    // Filter clients based on the search query if there's any search term
    const filteredClients = filterClients(group, searchQuery, clientsData);

    // If filtered clients exist, display them
    if (filteredClients.length > 0) {
      filteredClients.forEach(client => {
        const row = document.createElement('tr');  // Create a new row for each client

        const clientNameCell = document.createElement('td');
        const clientData = clientsData.find(c => c._id === client._id);
        // console.log("CLIENT username; ", clientData.username)
        // console.log("CLIENT room; ", clientData.group.groupName)

        // Check if client data is found and display either username or full name
        if (clientData) {
          clientNameCell.textContent = clientData.username || `${clientData.firstName} ${clientData.lastName}`;
        } else {
          clientNameCell.textContent = 'Unknown Client';  // If no client data found, display 'Unknown Client'
        }
        row.appendChild(clientNameCell);  // Add the client name to the row

        const actionsCell = document.createElement('td');
        actionsCell.innerHTML = `
          <button onclick="showMoveDropdown('${client._id}', '${group._id}')">Move</button>
          <button onclick="deleteClient('${client._id}', '${group._id}')"><i class="fas fa-trash"></i></button>
        `;
        row.appendChild(actionsCell);  // Add the actions to the row

        tableBody.appendChild(row);  // Add the client row to the table
      });
    } else if (searchQuery) {
      // If no clients match the search, show a message (only for search, not default view)
      const noClientsRow = document.createElement('tr');
      const noClientsCell = document.createElement('td');
      noClientsCell.colSpan = 3;
      noClientsCell.textContent = 'No clients match the search';
      noClientsRow.appendChild(noClientsCell);
      tableBody.appendChild(noClientsRow);
    }
  });

  // Set rendering flag back to false after rendering is done
  isRendering = false;
}

// Delete group function (frontend)
 
async function deleteGroup(groupId) {
  const confirmation = confirm('Are you sure you want to delete this group?');

  if (confirmation) {
    try {
      // Call API to delete the group from the server
      const response = await fetch(`${backendURL}/admin/groups/${groupId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`  // Assuming you have a token for authentication
        }
      });

      // Check if the response is successful
      const data = await response.json();

      if (data.success) {
        alert('Group deleted successfully!');
        // Refresh the groups list
        await fetchGroups();  // This will refetch the groups and display them
      } else {
        alert('Failed to delete the group');
      }
    } catch (error) {
      console.error('Error deleting group:', error);
      alert('An error occurred while deleting the group');
    }
  }
}

document.getElementById('toggle-group-tools-btn').addEventListener('click', () => {
    const groupTools = document.getElementById('group-tools');
    const toggleButton = document.getElementById('toggle-group-tools-btn');

    // Toggle the display of the group tools section
    if (groupTools.style.display === 'none' || groupTools.style.display === '') {
        groupTools.style.display = 'block'; // Show the group tools section
        toggleButton.textContent = 'Hide Group Tools'; // Change button text
    } else {
        groupTools.style.display = 'none'; // Hide the group tools section
        toggleButton.textContent = 'Show Group Tools'; // Change button text
    }
});


// Event listener for search input
const searchInput = document.getElementById('searchInput');

// Handle keydown for Backspace
searchInput.addEventListener('keydown', async (event) => {
  if (event.key === "Backspace") {
    // Clear the search query and show all clients when backspace is pressed
    searchInput.value = '';  // Clear the input field
    await displayGroups(availableGroups);  // Display all groups and clients immediately
  }
});

// Event listener for input changes (for typing and filtering)
searchInput.addEventListener('input', async () => {
  let query = searchInput.value.trim();  // Get search query and remove leading/trailing spaces
  console.log("Search Query: ", query);

  // If query is empty after trimming, display all groups and clients immediately
  if (query === '') {
    await displayGroups(availableGroups);  // Show all groups without any filtering
  } else {
    // If there's a non-empty query, show filtered results
    await displayGroups(availableGroups, query);
  }
});



async function showMoveDropdown(clientId, fromGroupId) {
    try {
        if (!availableGroups || availableGroups.length === 0) {
            alert('No available groups to move the client.');
            return; // Exit if no groups are available
        }

        const dropdownHtml = availableGroups.map(group => {
            return `<option value="${group._id}">${group.groupName}</option>`;
        }).join('');

        const moveModal = document.createElement('div');
        moveModal.classList.add('move-modal');
        moveModal.innerHTML = `
            <div class="modal-content">
                <h3>Move Client</h3>
                <select id="move-to-group">
                    <option value="">Select Group</option>
                    ${dropdownHtml}
                </select>
                <button onclick="moveClient('${clientId}', '${fromGroupId}')">Move</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
        `;
        document.body.appendChild(moveModal);
    } catch (error) {
        console.error('Error showing move dropdown:', error);
        alert('Error loading available groups');
    }
}

async function moveClient(clientId, fromGroupId) {
    const toGroupId = document.getElementById('move-to-group').value;

    if (toGroupId) {
        try {
            // Move client logic in the backend to update both group DB and client DB
            const response = await fetch(`${backendURL}/move-client`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    clientId,
                    fromGroupId,
                    toGroupId
                }),
            });

            const result = await response.json();
            if (result.success) {
                alert('Client moved successfully!');
                // Refetch groups and display them again
                await fetchGroups();  // This will refetch the groups and display them
            } else {
                alert('Failed to move client: ' + result.message);
            }
        } catch (error) {
            console.error('Error moving client:', error);
            alert('Error moving client');
        }
    } else {
        alert('Please select a group!');
    }

    closeModal();  // Close the modal
}

// Global variable to store the current group ID for adding clients
let currentGroupId = null;

// Show the modal for adding clients
function showAddClientModal(groupId) {
  currentGroupId = groupId;  // Store the current group ID
  document.getElementById('add-client-modal').style.display = 'flex';  // Show the modal
}
// Function to close the move modal
function closeModal() {
    document.getElementById('add-client-modal').style.display = 'none';  // Hide the modal
  const modal = document.querySelector('.move-modal');
  if (modal) {
    modal.remove();
  }
}

async function deleteClient(clientId, groupId) {
    const confirmed = confirm("Are you sure you want to delete this client from the group?");
    if (confirmed) {
        try {
            // Delete client logic in the backend to update both group DB and client DB
            const response = await fetch(`${backendURL}/admin/delete-client`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ clientId, groupId })
            });

            const result = await response.json();

            if (result.success) {
                alert("Client deleted successfully!");
                // Optionally, update the groups list in the UI
                const updatedGroups = groups.map(group => {
                    if (group._id === groupId) {
                        // Remove the client from the group's client list
                        group.clients = group.clients.filter(client => client._id !== clientId);
                    }
                    return group;
                });

                await fetchGroups();  // This will refetch the groups and display them
            } else {
                alert("Error deleting client.");
            }
        } catch (error) {
            console.error('Error deleting client:', error);
            alert('Error deleting client.');
        }
    }
}


async function addClientsToGroup() {
  const securityCodes = document.getElementById('securityCodesA').value
    .split(',')
    .map(code => code.trim())  // Trim whitespace around the codes
    .filter(code => code !== '');  // Remove empty strings from the array

  if (securityCodes.length > 0) {
    try {
      const response = await fetch(`${backendURL}/admin/add-clients`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          groupId: currentGroupId,  // Assuming currentGroupId is defined elsewhere in your code
          securityCodes: securityCodes,
        }),
      });

      const result = await response.json();

      if (result.success) {
        alert('Clients added successfully!');
        fetchGroups();  // Refresh the groups table
        closeModal();  // Close the modal
      } else {
        // Check if the error message includes the prompt to move the client
        if (result.message.includes('Do you want to move them here?')) {
          const confirmMove = confirm(result.message);

          if (confirmMove) {
            const clientId = result.clientId;  // Get the clientId from the server response
            const fromGroupId = result.fromGroupId;  // Get the fromGroupId from the server response

            if (clientId && fromGroupId) {
              // If user agrees to move the client, send a request to move the client
              const moveResponse = await fetch(`${backendURL}/admin/move-client`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  clientId: clientId,  // Correct clientId
                  fromGroupId: fromGroupId,  // Correct fromGroupId
                  toGroupId: currentGroupId,  // Correct current groupId (destination)
                }),
              });

              const moveResult = await moveResponse.json();
              if (moveResult.success) {
                alert('Client moved successfully!');
                fetchGroups();  // Refetch groups to reflect the move
              } else {
                alert('Error moving client: ' + moveResult.message);
              }
            } else {
              alert('Client ID or Group ID is missing.');
            }
          }
        } else {
          alert('Error adding clients: ' + result.message);
        }
      }
    } catch (error) {
      console.error('Error adding clients:', error);
      alert('Error adding clients.');
    }
  } else {
    alert('Please enter at least one valid security code.');
  }
}



// Show the Update Group form when the "Update Group" button is clicked
// Add this inside your displayGroups function after the "Update Group" button click handler

async function showUpdateGroupForm(group) {
    try {
        // Fetch the current group details from the backend
        const response = await fetch(`${backendURL}/group-details/${group._id}`);
        const data = await response.json();

        if (data.success) {
            const groupDetails = data.group;

            // Function to convert UTC date string to local datetime-local format
            const convertToLocalDatetimeLocalFormat = (utcDate) => {
                const localDate = new Date(utcDate);
                return localDate.toISOString().slice(0, 16); // Get the first 16 characters (YYYY-MM-DDTHH:mm)
            };

            // Pre-fill the form with current group details
            document.getElementById('flightNumber').value = groupDetails.tripDetails.flightInfo.flightNumber || '';
            document.getElementById('departure').value = groupDetails.tripDetails.flightInfo.departureTime 
                ? convertToLocalDatetimeLocalFormat(groupDetails.tripDetails.flightInfo.departureTime) 
                : '';
            document.getElementById('arrival').value = groupDetails.tripDetails.flightInfo.arrivalTime 
                ? convertToLocalDatetimeLocalFormat(groupDetails.tripDetails.flightInfo.arrivalTime) 
                : '';
            document.getElementById('departureAirport').value = groupDetails.tripDetails.flightInfo.departureAirport || '';
            document.getElementById('arrivalAirport').value = groupDetails.tripDetails.flightInfo.arrivalAirport || '';

            document.getElementById('busDepartureTime').value = groupDetails.tripDetails.busInfo.departureTime 
                ? convertToLocalDatetimeLocalFormat(groupDetails.tripDetails.busInfo.departureTime) 
                : '';
            document.getElementById('busDeparturePlace').value = groupDetails.tripDetails.busInfo.departurePlace || '';
            document.getElementById('busDestination').value = groupDetails.tripDetails.busInfo.destination || '';

            document.getElementById('hotelName').value = groupDetails.tripDetails.hotelInfo.hotelName || '';
            document.getElementById('location').value = groupDetails.tripDetails.hotelInfo.location || '';
            document.getElementById('checkInTime').value = groupDetails.tripDetails.hotelInfo.checkInTime 
                ? convertToLocalDatetimeLocalFormat(groupDetails.tripDetails.hotelInfo.checkInTime) 
                : '';
            document.getElementById('checkOutTime').value = groupDetails.tripDetails.hotelInfo.checkOutTime 
                ? convertToLocalDatetimeLocalFormat(groupDetails.tripDetails.hotelInfo.checkOutTime) 
                : '';

            document.getElementById('foodPlanDay').value = groupDetails.tripDetails.foodPlan[0]?.day || '';
            document.getElementById('foodPlanMeals').value = groupDetails.tripDetails.foodPlan[0]?.meals.join('\n') || '';

            // Now show the form
            const formContainer = document.getElementById('update-trip-form');
            formContainer.style.display = 'block';  // Show the form container

            // Store the groupId for later use in the update process
            window.currentGroupId = group._id;
        } else {
            alert('Failed to fetch group details.');
        }
    } catch (error) {
        console.error('Error fetching group details:', error);
        alert('Error fetching group details.');
    }
}




// Initial call to fetch and display the groups
fetchGroups();
// Modal for Haj Steps
const hajStepsModalHtml = `
<div id="hajStepsModal" style="display:none; position: fixed; top: 10%; left: 50%; transform: translateX(-50%); background: white; border: 1px solid #ccc; padding: 20px; z-index: 1000; width: 400px;">
    <h3>Manage Haj Steps</h3>
    <label for="hajStartTimeModal">Haj Start Time:</label>
    <input type="datetime-local" id="hajStartTimeModal" />
    <br/><br/>
    <label for="hajStepsInput">اختر خطوة الحج:</label>
    <select id="hajStepsInput" style="width: 100%; height: 40px;">
        <option value='{"title":"الإحرام"}'>الإحرام</option>
        <option value='{"title":"الطواف"}'>الطواف</option>
        <option value='{"title":"السعي بين الصفا والمروة"}'>السعي بين الصفا والمروة</option>
        <option value='{"title":"الإقامة في مكة"}'>الإقامة في مكة</option>
        <option value='{"title":"الذهاب إلى منى"}'>الذهاب إلى منى</option>
        <option value='{"title":"يوم عرفة"}'>يوم عرفة</option>
        <option value='{"title":"مزدلفة"}'>مزدلفة</option>
        <option value='{"title":"يوم النحر"}'>يوم النحر</option>
        <option value='{"title":"أيام التشريق"}'>أيام التشريق</option>
        <option value='{"title":"طواف الوداع"}'>طواف الوداع</option>
        <option value='{"title":"الخطوات النهائية"}'>الخطوات النهائية</option>
    </select>
    <br/><br/>
    <div id="hajMap" style="width: 100%; height: 300px;"></div>
    <button id="saveHajStepsBtn">Save</button>
    <button id="cancelHajStepsBtn">Cancel</button>
</div>
<div id="modalOverlay" style="display:none; position: fixed; top:0; left:0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
`;

document.body.insertAdjacentHTML('beforeend', hajStepsModalHtml);

let currentHajGroupId = null;
let map;
let selectedStepLocation = null;

// --- Open Modal Function ---
function openHajStepsModal(groupId) {
    currentHajGroupId = groupId;
    document.getElementById("hajStepsModal").style.display = 'block';
    document.getElementById("modalOverlay").style.display = 'block';

    const hajStepsSelect = document.getElementById("hajStepsInput");

    // Initialize the map if it hasn't been created yet
    if (!map) {
        map = L.map('hajMap').setView([21.4225, 39.8262], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

       // Fixing the map click handler to set the title correctly
map.on('click', function (e) {
    const { lat, lng } = e.latlng;
    const selectedOption = hajStepsSelect.selectedOptions[0];

    if (!selectedOption) {
        alert("يرجى اختيار خطوة قبل تحديد موقعها على الخريطة.");
        return;
    }

    const stepData = JSON.parse(selectedOption.value);
    if (!stepData.title) {
        alert("خطوة غير صالحة.");
        return;
    }

    const title = stepData.title; // Set the correct title from the selected step.

    if (selectedStepLocation?.marker) {
        map.removeLayer(selectedStepLocation.marker);
    }

    const marker = L.marker([lat, lng])
        .addTo(map)
        .bindPopup(title)
        .openPopup();

    selectedStepLocation = { lat, lng, marker, title }; // Ensure the correct title is stored here.
});
    }

    // Fetch existing step data
    fetch(`${backendURL}/group-haj-steps/${groupId}`)
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                const hajStartTimeInput = document.getElementById("hajStartTimeModal");

                if (data.hajStartTime) {
                    const dt = new Date(data.hajStartTime);
                    hajStartTimeInput.value = dt.toISOString().slice(0, 16);  // Format datetime-local
                } else {
                    hajStartTimeInput.value = '';
                }

                const existingTitle = data.hajSteps[0]?.title; // Assuming there is only one step in hajSteps
                [...hajStepsSelect.options].forEach(option => {
                    const parsed = JSON.parse(option.value);
                    option.selected = (parsed.title === existingTitle);
                });

                if (data.hajLocations?.length > 0) {
                    const loc = data.hajLocations[0];  // Assuming there is one location (the current step's location)
                    const marker = L.marker([loc.lat, loc.lng])
                        .addTo(map)
                        .bindPopup(loc.title)
                        .openPopup();
                    map.setView([loc.lat, loc.lng], 13);
                    selectedStepLocation = { lat: loc.lat, lng: loc.lng, marker, title: loc.title };
                }
            } else {
                alert("Failed to fetch Haj steps.");
            }
        })
        .catch(err => {
            console.error(err);
            alert("Error fetching Haj steps.");
        });
}

// --- Cancel Modal ---
document.getElementById("cancelHajStepsBtn").addEventListener("click", () => {
    document.getElementById("hajStepsModal").style.display = 'none';
    document.getElementById("modalOverlay").style.display = 'none';
});

// --- Save Haj Steps ---

document.getElementById("saveHajStepsBtn").addEventListener("click", () => {
    const hajStartTimeInput = document.getElementById("hajStartTimeModal").value;
    const hajStepsSelect = document.getElementById("hajStepsInput");

    if (!currentHajGroupId) {
        alert("No group selected.");
        return;
    }

    // Only one hajStep is selected
    const selectedOption = hajStepsSelect.selectedOptions[0];
    if (!selectedOption) {
        alert("Please select a Haj step.");
        return;
    }

    const parsed = JSON.parse(selectedOption.value);
    const selectedStepTitle = parsed.title; // Get the selected step title

    const hajStepsArray = [{
        title: selectedStepTitle,
        completed: false
    }];

    const hajStartTime = hajStartTimeInput
        ? new Date(hajStartTimeInput).toISOString()
        : null;

    // Ensure the location title matches the selected step title
    const hajLocations = selectedStepLocation
        ? [{
            title: selectedStepTitle, // Use the selected step title instead of location title
            lat: selectedStepLocation.lat,
            lng: selectedStepLocation.lng
        }]
        : [];

    console.log("Sending payload:", {
        hajStartTime,
        hajSteps: hajStepsArray,
        hajLocations
    });

    const payload = {
        hajStartTime,
        hajSteps: hajStepsArray,
        hajLocations
    };

    fetch(`${backendURL}/group-haj-steps/${currentHajGroupId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                alert("Haj step and location updated successfully.");
                document.getElementById("hajStepsModal").style.display = 'none';
                document.getElementById("modalOverlay").style.display = 'none';
            } else {
                alert("Failed to update Haj steps.");
            }
        })
        .catch(err => {
            console.error(err);
            alert("Error updating Haj steps.");
        });
});



// Update the group form submission handler
const formUpdate = document.getElementById('update-trip-form');
formUpdate.addEventListener('submit', async function (event) {
    event.preventDefault();  // Prevent default form submission

    if (!window.currentGroupId) {
        alert('No group selected.');
        return;
    }

    // Collect the updated form data
    const tripData = {
        flightInfo: {
            flightNumber: document.getElementById('flightNumber').value || '',
            departureTime: document.getElementById('departure').value ? new Date(document.getElementById('departure').value).toISOString() : '',
            arrivalTime: document.getElementById('arrival').value ? new Date(document.getElementById('arrival').value).toISOString() : '',
            departureAirport: document.getElementById('departureAirport').value || '',
            arrivalAirport: document.getElementById('arrivalAirport').value || '',
            seat: document.getElementById('seat').value || ''
        },
        busInfo: {
            departureTime: document.getElementById('busDepartureTime').value ? new Date(document.getElementById('busDepartureTime').value).toISOString() : null,
            departurePlace: document.getElementById('busDeparturePlace').value || null,
            destination: document.getElementById('busDestination').value || null
        },
        hotelInfo: {
            hotelName: document.getElementById('hotelName').value || '',
            roomNumber: document.getElementById('roomNumber').value || '',
            location: document.getElementById('location').value || '',
            checkInTime: document.getElementById('checkInTime').value ? new Date(document.getElementById('checkInTime').value).toISOString() : null,
            checkOutTime: document.getElementById('checkOutTime').value ? new Date(document.getElementById('checkOutTime').value).toISOString() : null
        },
        foodPlan: [{
            day: document.getElementById('foodPlanDay').value || '',
            meals: document.getElementById('foodPlanMeals').value.split('\n').map(meal => {
                const parts = meal.split(':');
                const mealType = parts[0].trim();
                const menu = parts[1] ? parts[1].trim() : '';
                return `${mealType}: ${menu}`;
            })
        }]
    };

    // Send the update request to the server
    try {
        const response = await fetch(`${backendURL}/update-trip/${window.currentGroupId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(tripData)
        });

        const data = await response.json();
        if (data.success) {
            alert('Group details updated successfully!');
            // Optionally close the form or reset the form
            formUpdate.reset();
            formUpdate.style.display = 'none';  // Hide form
        } else {
            alert('Failed to update group details.');
        }
    } catch (error) {
        console.error('Error updating group details:', error);
        alert('Error updating group details.');
    }
});

// Get the elements
const newGroupBtn = document.getElementById('newGroupBtn');
const hideFormBtn = document.getElementById('hideFormBtn');
const createGroupForm = document.getElementById('create-group-form');

// Show the form when the "New Group" button is clicked
newGroupBtn.addEventListener('click', () => {
  createGroupForm.style.display = 'block'; // Show the form
  newGroupBtn.style.display = 'none'; // Hide the "New Group" button
});

// Hide the form when the "Hide Form" button is clicked
hideFormBtn.addEventListener('click', () => {
  createGroupForm.style.display = 'none'; // Hide the form
  newGroupBtn.style.display = 'block'; // Show the "New Group" button
});

// Handle the form submission
const form = document.getElementById('create-group-form');
form.addEventListener('submit', async (e) => {
  e.preventDefault();

  // Get the form inputs
  const groupName = document.getElementById('groupName').value;
  const securityCodes = document.getElementById('securityCodes').value.split(',');  // Assuming comma-separated security codes
  const flightInfo = {
    flightNumber: document.getElementById('flightNumberC').value,
    departureTime: '2024-07-01T10:00:00Z', // Example time
    arrivalTime: '2024-07-01T14:00:00Z', // Example time
    departureAirport: 'JFK',
    arrivalAirport: 'LHR',
    seat: '12A'
  };
  const busInfo = {
    departureTime: '2024-07-01T15:00:00Z',
    departurePlace: document.getElementById('busDeparturePlaceC').value,
    destination: 'Hotel A'
  };
  const hotelInfo = {
    hotelName: document.getElementById('hotelNameC').value,
    roomNumber: '101',
    location: 'London, UK',
    checkInTime: '2024-07-01T16:00:00Z',
    checkOutTime: '2024-07-07T11:00:00Z'
  };
  const foodPlan = [
    {
      day: '2024-07-01',
      meals: [
        { type: 'breakfast', mealDetails: 'Continental breakfast' },
        { type: 'lunch', mealDetails: 'Buffet lunch' },
        { type: 'dinner', mealDetails: 'Set dinner menu' }
      ]
    }
  ];

  // Get adminId (This should be fetched from session, token, or a global variable)

  // Create data object to send to the server
  const data = {
    groupName,
    securityCodes,
    adminId,  // Include adminId
    flightInfo,
    busInfo,
    hotelInfo,
    foodPlan
  };

  try {
    const response = await fetch(`${backendURL}/create-group`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });

    const result = await response.json();
    if (result.success) {
      alert('Group created successfully!');
      // Optionally reset the form
      form.reset();
      // Hide the form and show the "New Group" button
      createGroupForm.style.display = 'none';
      newGroupBtn.style.display = 'block';
    } else {
      alert('Error creating group: ' + result.message);
    }
  } catch (err) {
    console.error('Error:', err);
    alert('Error creating group');
  }
});

      </script>
      

    <script>// Ensure that adminId is retrieved properly from localStorage on the admin page
    
    document.getElementById('updateTripInfoForm').addEventListener('submit', function(event) {
    event.preventDefault();

      // Collect values from the form
      const seat = document.getElementById('seat').value;
    const flightNumber = document.getElementById('flightNumber').value || null
    const airlineCompany = document.getElementById('airlineCompany').value || null

    const roomNumber = document.getElementById('roomNumber').value;
    const hotelName = document.getElementById('hotelName').value || null

    const arafaKhayma = document.getElementById('arafaKhayma').value || null
    const minaKhayma = document.getElementById('minaKhayma').value || null


    // Send updated trip info to the server
    socket.emit('updateTripInfo', {
        seat,
        flightNumber,
        airlineCompany,
        roomNumber,
        hotelName,
        arafaKhayma,
        minaKhayma
      
    });
});

    // Get the refresh button element by ID
const refreshButton = document.getElementById('refreshButton');

// Add event listener to the refresh button
refreshButton.addEventListener('click', function() {
    location.reload();  // Refresh the page when the button is clicked
});

let callStartTime = null;  // To track when the call starts
let callInterval = null;   // To handle the setInterval for updating the timer
let elapsedTime = 0;  
let clientName = null
const callTimerElement = document.getElementById('callTimer'); 
let idloc =null
let soc;
        const adminId = localStorage.getItem('adminId');  // Retrieve adminId from localStorage
        const clientId = localStorage.getItem('clientId');  // This should be null for admins
       // Retrieve the email of the logged-in admin from localStorage
     // end

          // WebSocket connection
          const socket = io(`${backendURL}`, { transports: ['websocket'] });
         
          socket.on('connect', () => {
        console.log('Socket connected with ID:', socket.id);
        localStorage.setItem('socketId', socket.id)

        // Emit the adminLogin event to set the socketId for the admin
        socket.emit('adminLogin', adminId);
    });

    socket.on('connect_error', (error) => {
        console.error('Socket connection error:', error);
    });
setTimeout(() => {
    soc = localStorage.getItem('socketId');
    console.log('Socket ID from localStorage after 5 seconds:', soc);
}, 5000); 
        
          let storedAdminId = null;
          let storedClientId = null;
        
        // Retrieve the username from localStorage
        const adminName = localStorage.getItem('username'); // Get the username from localStorage
        
        if (adminName) {
            document.getElementById('adminName').textContent = adminName;
        } else {
            alert('Admin is not logged in.');
            window.location.href = '/login.html'; // Redirect to login if admin is not logged in
        }
        
        // Logout function to clear session data
        function logout() {
            localStorage.removeItem('token');
            localStorage.removeItem('username');
            alert('You have been logged out!');
            window.location.href = 'index.html'; // Redirect to login page
        }
        
   


  // map ------------------------------------------------------------------------------------------------
  let windowMap = null; // Store the map globally
let adminLocation = null; // Store the admin's location
let parentLocation = null; // Store the parent's location
let routeControl = null; // Store the routing control globally
let adminMarker = null;  // This will store the Admin marker

// 1. Get Admin's Location (using the browser's geolocation)
function getAdminLocation() {
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;

            // console.log(`${adminName} Location:`, latitude, longitude);

            // Save the admin location globally
            adminLocation = { lat: latitude, lng: longitude };

            // Initialize the map with admin's location if not already initialized
            if (!windowMap) {
                initializeMap(latitude, longitude);  // Initialize map only once
            } else {
                updateAdminLocationOnMap(latitude, longitude);  // Update the marker if map is already initialized
            }

            // Update route if parent location is available
            if (parentLocation) {
                updateRoute(adminLocation, parentLocation); // Update route
            }
        }, function(error) {
            console.error("Error getting location:", error);
        });
    } else {
        console.error("Geolocation is not supported by this browser.");
    }
}

// Create a custom blue dot icon with shadow for the admin
const adminIcon = L.icon({
    iconUrl: 'dot.png',  // The path to your custom blue dot icon
    iconSize: [20, 20],                          // Adjust size of the icon (width, height)
    iconAnchor: [15, 15],                        // Anchor the icon at the center
    popupAnchor: [0, -15],                       // Position of popup relative to the icon
                         // Position of shadow relative to the icon
});

const clientIcon = L.icon({
    iconUrl: 'https://clarecrc.com/wp-content/plugins/Citizen%20Request%20Plugin/map/mapmarker.png', // Path to the client icon
    iconSize: [30, 30],      // Adjust size of the icon (width, height)
    iconAnchor: [15, 30],    // Anchor the icon at the center
    popupAnchor: [0, -15],   // Position of popup relative to the icon
});


// 2. Initialize the Map with Admin (Child)'s Location
// Function to initialize the map (same as your original code)
// Function to initialize the map (same as your original code)
// Store the geofence information globally
let geofence = null;
let geofenceMarker = null;
let geofenceCircle = null;
let geofenceActive = true;  // Flag to track if the geofence is active or not
let geofenceStopButton = document.getElementById('stopGeofence');  // Button to stop the geofence

// Initialize the map (same code as before)
function initializeMap(lat, lng) {
    windowMap = L.map('map').setView([lat, lng], 13);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(windowMap);

    // Add a marker for admin location (can remove if not needed)
    L.marker([lat, lng], { icon: adminIcon })
        .addTo(windowMap)
        .on('mouseover', function () {
            this.bindPopup(`${adminName}'s Location`).openPopup();
        })
        .on('mouseout', function () {
            this.closePopup();
        });

    // Allow the admin to click on the map to set geofence center
    windowMap.on('click', function (e) {
        const lat = e.latlng.lat;
        const lng = e.latlng.lng;

        // Remove previous geofence marker and circle if they exist
        if (geofenceMarker) {
            windowMap.removeLayer(geofenceMarker);
        }
        if (geofenceCircle) {
            windowMap.removeLayer(geofenceCircle);
        }

        // Set the new marker for the geofence center
        geofenceMarker = L.marker([lat, lng]).addTo(windowMap);

        // Set the new circle with a default radius (100 meters initially)
        const radius = parseInt(document.getElementById('radius').value) || 100; // Get radius from input or default to 100
        geofenceCircle = L.circle([lat, lng], {
            radius: radius,
            color: 'blue',
            fillColor: 'blue',
            fillOpacity: 0.2
        }).addTo(windowMap);

        // Store the geofence data
        geofence = {
            latitude: lat,
            longitude: lng,
            radius: radius
        };
    });
}

function setGeofence() {
    if (geofence) {
        // Emit geofence data to the server
        socket.emit('setGeofence', geofence);
        alert('Geofence set successfully!');
        geofenceActive = true;  // Geofence is now active
    } else {
        alert('Please click on the map to set the geofence center!');
    }
}
// Stop Geofence button logic



// Stop geofence when clicked on the "Stop Geofence" button
geofenceStopButton.addEventListener('click', function() {
    if (geofenceActive) {
        // Emit a signal to the server to stop geofence
        socket.emit('stopGeofence');  // Tell the server to stop the geofence checks
document.getElementById("alert-container").style.display = "none"
        // Disable the geofence on the admin side
        geofenceActive = false;  // Set geofence to inactive
        geofenceStopButton.disabled = true;  // Disable the Stop Geofence button

        alert('Geofence has been stopped.');
        
        // Optionally, clear the geofence markers from the map
        if (geofenceMarker) windowMap.removeLayer(geofenceMarker);
        if (geofenceCircle) windowMap.removeLayer(geofenceCircle);
        
        // Reset geofence data if needed
        geofence = null;
    }
});

// Listen for the geofenceStopped signal on the server (from the admin side)
socket.on('geofenceStopped', () => {
    console.log('Admin has stopped the geofence.');
    // Optionally handle the event here on admin side if needed
    // For example, disable geofence-related functionality
});

function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;  // Earth radius in meters
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // Distance in meters
    }
// Toggle visibility of the map and switch the button text between "+" and "X"
document.getElementById('toggle-map').addEventListener('click', function() {
    const mapDiv = document.getElementById('map');
    const toggleBtn = document.getElementById('toggle-map');
    const icon = toggleBtn.querySelector('i'); // Get the icon inside the toggle button
    if (!mapDiv.classList.contains('visible')) {
        // Show the map
        mapDiv.classList.add('visible'); // Add class to trigger the transition
        icon.classList.remove('fa-map-marker-alt');  // Remove the map icon
        icon.classList.add('fas', 'fa-times');      // Add the "X" icon

       
    } else {
        // Hide the map
        mapDiv.classList.remove('visible');  // Remove the "visible" class to trigger the transition
        icon.classList.remove('fa-times');  // Remove the "X" icon
        icon.classList.add('fas', 'fa-map-marker-alt');  // Add the map icon back
    }
});

function updateAdminLocationOnMap(lat, lng) {
    
    // console.log("Updating Admin location on map:", lat, lng);

    if (windowMap) {
        // Remove the old admin marker if it exists
        if (adminMarker) {
            windowMap.removeLayer(adminMarker);
        }

        // Add the new admin marker with the updated location
        adminMarker = L.marker([lat, lng], { icon: adminIcon })  // Store reference to the new marker
            .addTo(windowMap)
            .on('mouseover', function () {
                this.bindPopup(`${adminName}'s Location`).openPopup();
            })
            .on('mouseout', function () {
                this.closePopup();
            });
    } else {
        console.error("Map is not initialized yet.");
    }
}




let trackingInterval = null;  // To store the interval ID for stopping tracking
let clientMarker = null;      // To store the client marker

// Function to fetch the parent's location by secret code
function getParentLocation(secretCode) {
    if (!secretCode) {
        alert("Please enter a parent secret code.");
        return;
    }

    fetch(`${backendURL}/getParentLocation/${secretCode}`, {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
    })
    .then(response => response.json())
    .then(data => {
        console.log("Parent Location Response:", data); // Debugging line
        if (data.success) {
            clientName = data.username;
            const latitude = data.latitude;
            const longitude = data.longitude;
            idloc = data.clientId;
            // console.log(`${clientName} Location:`, latitude, longitude);
            
            if (latitude && longitude) {
                parentLocation = { lat: latitude, lng: longitude };

                // Remove existing marker if there is one
                if (clientMarker) {
                    windowMap.removeLayer(clientMarker);
                }

                // Update the parent location on the map
                updateParentLocationOnMap(latitude, longitude, clientName);

                // Start emitting location data at regular intervals
                if (trackingInterval) {
                    clearInterval(trackingInterval); // Clear any existing intervals
                }

                // Start tracking by emitting location every 5 seconds
                trackingInterval = setInterval(() => {
                    emitLocationData(idloc);
                }, 5000);
            } else {
                console.error("Parent location is invalid:", latitude, longitude);
            }
        } else {
            console.error("Failed to fetch parent location:", data.message);
        }
    })
    .catch(error => {
        console.error('Error fetching parent location:', error);
    });
}

// Function to stop tracking the client
function stopTrackingClient() {
    if (trackingInterval) {
        clearInterval(trackingInterval);  // Stop emitting location data
        trackingInterval = null;  // Reset the interval ID
    }

    // Remove the client marker if it exists
    if (clientMarker) {
        windowMap.removeLayer(clientMarker);
        clientMarker = null;  // Reset the marker
    }

    console.log("Stopped tracking the client.");
}

// Function to update the parent (client) location on the map with the new client icon
// Function to update the client location on the map
function updateParentLocationOnMap(lat, lng, clientName) {
    if (windowMap) {
        // Remove the old client marker if it exists
        if (clientMarker) {
            windowMap.removeLayer(clientMarker);
        }

        // Add the new client marker with the custom client icon
        clientMarker = L.marker([lat, lng], { icon: clientIcon })
            .addTo(windowMap)
            .on('mouseover', function () {
                this.bindPopup(`${clientName}'s Location`).openPopup();
            })
            .on('mouseout', function () {
                this.closePopup();
            });
    } else {
        console.error("Map is not initialized yet.");
    }
}

// Function to emit location data (assuming this is for the admin)
function emitLocationData(clientId) {
    if (adminLocation && parentLocation && clientId) {
        console.log("Emitting Admin and Parent locations to client:", clientId);
        socket.emit('sendLocationsToClient', { adminLocation, parentLocation, clientId });
    } else {
        console.error("Client ID is undefined or location data is missing");
    }
}


// 6. Update the Route from Admin (Child) to Parent
function updateRoute(adminLocation, parentLocation) {
    if (!parentLocation || !windowMap) {
        console.error("Map or locations are not available yet");
        return;
    }

    // If routeControl exists, update the route
    if (routeControl) {
        routeControl.setWaypoints([L.latLng(adminLocation.lat, adminLocation.lng), L.latLng(parentLocation.lat, parentLocation.lng)]);
    } else {
        // If routeControl doesn't exist, create it for the first time
        routeControl = L.Routing.control({
            waypoints: [
                L.latLng(adminLocation.lat, adminLocation.lng),
                L.latLng(parentLocation.lat, parentLocation.lng)
            ],
            createMarker: function() { return null; }, // Hide markers
            routeWhileDragging: true  // Allow route dragging
        }).addTo(windowMap);  // Add the route to the map
    }
}

// Call getAdminLocation once when the page loads to fetch the admin's location
getAdminLocation();

// Update every 5 seconds
setInterval(getAdminLocation, 5000);  // Update admin's location every 5 seconds





// Listen for the button click to send location data to Client page
document.getElementById("getParentLocationButton").addEventListener("click", function() {
    const secretCode = document.getElementById("secretCodeInput").value;
    getParentLocation(secretCode);  // Fetch and send Parent's location
});

// Toggle the "Client Log Tools" visibility
document.getElementById('toggleClientLogTools').addEventListener('click', () => {
    const clientLogTools = document.getElementById('clientLogTools');
    const toggleButton = document.getElementById('toggleClientLogTools');

    if (clientLogTools.style.display === 'none') {
        // Show the client log tools
        clientLogTools.style.display = 'block';
        toggleButton.textContent = 'Hide Client Log Tools';  // Change button text to "Hide Client Log Tools"
    } else {
        // Hide the client log tools
        clientLogTools.style.display = 'none';
        toggleButton.textContent = 'Client Log Tools';  // Change button text back to "Client Log Tools"
    }
});

// Toggle the "Location Tools" visibility
document.getElementById('toggleLocationTools').addEventListener('click', () => {
    const locationTools = document.getElementById('locationTools');
    const toggleButton = document.getElementById('toggleLocationTools');

    if (locationTools.style.display === 'none') {
        // Show the location tools
        locationTools.style.display = 'block';
        toggleButton.textContent = 'Hide Location Tools';  // Change button text to "Hide Location Tools"
    } else {
        // Hide the location tools
        locationTools.style.display = 'none';
        toggleButton.textContent = 'Location Tools';  // Change button text back to "Location Tools"
    }
});

socket.emit('adminLogin', adminId);
document.addEventListener('DOMContentLoaded', function() {

    socket.emit('adminLogin', adminId);
    const token = localStorage.getItem('token');  // Get the JWT token from localStorage

    if (!token) {
        window.location.href = 'login.html';  // Redirect to login if not authenticated
        return;
    }

    const adminEmail = localStorage.getItem('email');  // Get admin email from localStorage
    const adminName = localStorage.getItem('username'); // Get admin name from localStorage
    const adminPhoneNumber = localStorage.getItem('phoneNumber'); // Get phone number
    const adminAge = localStorage.getItem('age'); // Get admin age
    

    if (adminEmail && adminName) {
        document.getElementById('adminName').textContent = adminName;
        document.getElementById('adminEmail').textContent = adminEmail;
        document.getElementById('adminPhoneNumber').textContent = adminPhoneNumber;
        document.getElementById('adminAge').textContent = adminAge;
    } else {
        alert('Admin is not logged in.');
        window.location.href = '/login.html'; // Redirect if admin is not logged in
    }

    let clientUpdateInterval = null;  // To store the setInterval reference

// Toggle visibility of the client list
document.getElementById('toggleClientList').addEventListener('click', () => {
  const clientsList = document.getElementById('clientsList');
  const toggleButton = document.getElementById('toggleClientList');

  if (clientsList.style.display === 'none') {
    // Show the client list
    clientsList.style.display = 'block';
    toggleButton.textContent = 'Hide List Of Clients';  // Change button text

    // Start or restart the interval to update clients every 30 seconds
    startClientUpdate();
  } else {
    // Hide the client list
    clientsList.style.display = 'none';
    toggleButton.textContent = 'List Of Clients';  // Change button text back

    // Stop the interval to stop updating the list
    stopClientUpdate();
  }
});

// Function to start updating the client list every 30 seconds
function startClientUpdate() {
  if (!clientUpdateInterval) {
    fetchClientsInDom()
    clientUpdateInterval = setInterval(fetchClientsInDom, 30000);  // Refresh every 30 seconds
  }
}

// Function to stop the update interval
function stopClientUpdate() {
  if (clientUpdateInterval) {
    clearInterval(clientUpdateInterval);  // Stop the interval
    clientUpdateInterval = null;
  }
}

    function fetchClientsInDom() {
    const adminEmail = localStorage.getItem('email');
    
    // Fetch clients from backend
    fetch(`${backendURL}/admin/clients?adminEmail=` + encodeURIComponent(adminEmail))
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const clientsList = document.getElementById('clientsList');
                clientsList.innerHTML = ''; // Clear current list

               // Inside your client iteration (where you're displaying clients)
data.clients.forEach(client => {
    // console.log(client);  // Log the entire client object to verify group data
    // console.log(client.username + " has group: " + client.group); // Log to verify group info

    const clientItem = document.createElement('li');
    clientItem.setAttribute('id', `client-${client._id}`);  // Unique ID for each client

    const updateTripInfoButton = document.createElement('button');
    updateTripInfoButton.innerText = "Update Trip Info";
    updateTripInfoButton.onclick = function() {
        showUpdateTripInfoForm(client._id);
    };

    // Create status container (assuming you already have status image logic)
    const statusDotContainer = document.createElement('div');
    statusDotContainer.id = "icon-container";
    const statusUserImage = document.createElement('img');
    statusUserImage.id = "img";
    if (client.gender === 'male') {
        statusUserImage.src = 'male.png';
    } else if (client.gender && client.gender.toLowerCase() === 'female') {
        statusUserImage.src = 'women.png';
    } else {
        statusUserImage.src = 'male.png';
    }

    // Create status dot (green for online, red for offline)
    const statusDot = document.createElement('span');
    statusDot.classList.add('status-dot');
    if (client.status === 'online') {
        statusDot.style.backgroundColor = '#56d65e';
    } else {
        statusDot.style.backgroundColor = 'red';
    }
    statusDotContainer.appendChild(statusUserImage);  // Add user image
    statusDotContainer.appendChild(statusDot);  // Add status dot
 // Fetch trip info for the current client
 fetch(`${backendURL}/tripInfo/${client._id}`)
                    .then(response => response.json())
                    .then(tripData => {
                        if (tripData.success) {
                            const { tripInfo } = tripData;
                            const flightNumber = tripInfo.flightInfo ? tripInfo.flightInfo.flightNumber : 'Not available';
                            const airlineCompany = tripInfo.flightInfo ? tripInfo.flightInfo.airlineCompany : 'Not available';
                            const hotelName = tripInfo.hotelInfo ? tripInfo.hotelInfo.hotelName : 'Not available';
                            const roomNumber = tripInfo.hotelInfo ? tripInfo.hotelInfo.roomNumber : 'Not available';
                            const seat = tripInfo.flightInfo ? tripInfo.flightInfo.seat : 'Not available';
                            const arafaKhayma = tripInfo.arafaKhayma
                            const minaKhayma = tripInfo.minaKhayma 

    // Create client information block
    const clientText = document.createElement('span');
    // Format the client information as a JSON string
    const clientInfo = JSON.stringify({
            code: client.securityCode,
            username: client.username,
            group: client.group ? client.group.groupName : "No group",
            status: client.status,
            hotelName: hotelName,
            roomNumber: roomNumber,
            companyName: airlineCompany,
            flightNumber: flightNumber,
            seat: seat,
            arafaKhayma: arafaKhayma,
            minaKhayma: client.minaKhayma,
            firstName: client.firstName,
            lastName: client.lastName,
            email: client.email,
            gender: client.gender,
            age: client.age
        });

                            clientText.innerHTML = `
                                <h3><strong>${client.username}</strong></h3>
                                <button class="toggle-details-btn">Details</button>
                                <div class="client-details" style="display: none;">
                                    <h3>Code: ${client.securityCode}</h3>
                                    <p>${client.username} - Group: ${client.group ? client.group.groupName : 'No group'}</p>
                                    <p id="barcode">${client.securityCode}</p>
                                    <h4>Status: ${client.status}</h4>
                                    <p>Hotel Name : ${hotelName}</p>
                                    <p>Room Number: ${roomNumber}</p>
                                    <p>Company Name : ${airlineCompany}</p>
                                    <p>Flight Number: ${flightNumber}</p>
                                    <p>Seat: ${seat}</p>
                                    <p>Khayma Arafa Number: ${arafaKhayma}</p>
                                    <p>Khayma Mina Number: ${minaKhayma}</p>

                                       <p><strong>First Name:</strong> ${client.firstName}</p>
                        <p><strong>Last Name:</strong> ${client.lastName}</p>
                        <p><strong>Email:</strong> ${client.email}</p>
                        <p><strong>Gender:</strong> ${client.gender}</p>
                        <p><strong>Age:</strong> ${client.age}</p>
                                    <label for="saveLocation-${client._id}">
                                        Save Location
                                        <input type="checkbox" id="saveLocation-${client._id}">
                                    </label>
                                    <button class="edit-button" data-client-id="${client._id}">Edit</button>
                                </div>
                            `;

                            const qrcodeDiv = document.createElement('div');
qrcodeDiv.id = "qrcode";  // Set ID for the QR code div
qrcodeDiv.setAttribute("data-client-info", clientInfo); 
qrcodeDiv.style.display = 'none';  // Initially hide the QR code

    // Event listener for toggling the details
    const toggleDetailsBtn = clientText.querySelector('.toggle-details-btn');
    const clientDetails = clientText.querySelector('.client-details');

    // Toggle visibility when the button is clicked
    toggleDetailsBtn.addEventListener('click', () => {
        if (clientDetails.style.display === 'none') {
            clientDetails.style.display = 'block';
            toggleDetailsBtn.textContent = 'Hide';
        } else {
            clientDetails.style.display = 'none';
            toggleDetailsBtn.textContent = 'Details';
        }
    });
    
    // Add event listener for image click to show buttons
    statusDotContainer.addEventListener('click', () => {
        // Show the buttons for 5 seconds
        showButtonsFor5Seconds(clientItem, statusDotContainer);
    });

    clientText.addEventListener('click', () => {
        // Create a temporary input field to select the text
        const tempInput = document.createElement('input');
        tempInput.value = client.securityCode;  // Set the value as the security code
        document.body.appendChild(tempInput);  // Append the input to the document
        tempInput.select();  // Select the text in the input field
        document.execCommand('copy');  // Execute the copy command
        document.body.removeChild(tempInput);  // Remove the input field

        // Optional: Provide feedback to the user (e.g., show an alert or change text)
        // alert('Security code copied to clipboard!');
    });

    // Create buttons for each client
    const callButton = document.createElement('button');
    callButton.textContent = "Call";
    callButton.classList.add('hidden', 'action-button'); // Hide initially
    // Disable call button if client is offline
    if (client.status === 'offline') {
        callButton.disabled = true;
        callButton.onclick = function() {
            alert(`Sorry, ${client.username} is offline now. Try later.`);
        };
    } else {
        callButton.onclick = function() { startCalla(client.socketId, client.username, client.gender); 

            console.log("You are calling the client: ", client , " Username: ", client.username)
        };
    }

    const getParentButton = document.createElement('button');
    getParentButton.textContent = "Location";
    getParentButton.classList.add('hidden', 'action-button'); // Hide initially
    getParentButton.onclick = function() { getParentLocation(client.securityCode); };

    const stopTrackingButton = document.createElement('button');
    stopTrackingButton.textContent = "Stop";
    stopTrackingButton.classList.add('hidden', 'action-button'); // Hide initially
    stopTrackingButton.onclick = function() { stopTrackingClient(client._id); };
    const QrCode = document.createElement('button');
    QrCode.textContent = "Show QR";
    // Append elements to the client item
    clientItem.appendChild(clientText);
    clientText.appendChild(updateTripInfoButton);  // Append button to client info
    clientText.appendChild(QrCode);
    clientItem.appendChild(qrcodeDiv);
    clientItem.appendChild(statusDotContainer);  // Add client info

    clientItem.appendChild(callButton);  // Add call button
    clientItem.appendChild(getParentButton);  // Add getParent button
    clientItem.appendChild(stopTrackingButton);  // Add stop tracking button
   

    clientsList.appendChild(clientItem);
    // Toggle the visibility of the QR code when the "Show QR" button is clicked
QrCode.addEventListener('click', () => {
    if (qrcodeDiv.style.display === 'none') {
        qrcodeDiv.style.display = 'block';  // Show the QR code
        QrCode.textContent = 'Hide QR';  // Change button text to "Hide QR"
    } else {
        qrcodeDiv.style.display = 'none';  // Hide the QR code
        QrCode.textContent = 'Show QR';  // Change button text back to "Show QR"
    }
});

    setupClientLocationTracking(client);
    // Generate the QR code using the QRCode.js library
const qrcode = new QRCode(qrcodeDiv, {
    text: qrcodeDiv.getAttribute("data-client-info"),  // Retrieve client info from the data attribute
    width: 256,        // Set the width of the QR code
    height: 256,       // Set the height of the QR code
    colorDark: "#000000",  // Dark color for QR code
    colorLight: "#ffffff", // Light color for QR code
    correctLevel: QRCode.CorrectLevel.H  // Error correction level (High)
});
    
    // Event listener for Edit button click
    document.querySelectorAll('.edit-button').forEach(button => {
        button.addEventListener('click', function() {
            // Directly get the clientId from the button's data attribute
            console.log("clicked to edit")
            const clientId = this.getAttribute('data-client-id');
            
            // Prefill the form fields with current client information
            document.getElementById('gender').value = client.gender || '';  
            document.getElementById('firstName').value = client.firstName || '';
            document.getElementById('lastName').value = client.lastName || '';
            
            // Show the update form
            document.getElementById('updateClientForm').style.display = 'block';
            document.getElementById('updateClientForm').setAttribute('data-client-id', clientId);
        });
    });
}})
});

                } else {
                    console.log('No clients found');
                }
            })
            .catch(error => {
                console.error('Error fetching clients:', error);
            });
    }

    // Fetch clients every 30 seconds to refresh status
    setInterval(fetchClientsInDom, 300000);  // Refresh clients list every 30 seconds
    fetchClientsInDom(); // Initial call to fetch clients

    
    // Update Trip Info Button Click Handler
    function showUpdateTripInfoForm(clientId) {
    // Fetch the current trip info for the client before showing the form
    fetch(`${backendURL}/tripInfo/${clientId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const tripInfo = data.tripInfo;
                
                // Generate form with existing data
                const formHTML = `
                    <h3>Update Trip Info for Client</h3>
                    <form id="updateTripInfoForm">
                        <!-- Flight Info Section -->
                        <h4>Flight Info:</h4>
                        
                        <!-- Seat Input Field -->
                        <label for="seat">Seat</label>
                        <input type="text" id="seat" name="seat" value="${tripInfo.flightInfo?.seat || 'Not available'}" required><br>

                        <!-- Flight Number Input Field -->
                        <label for="flightNumber">Flight Number</label>
                        <input type="text" id="flightNumber" name="flightNumber" value="${tripInfo.flightInfo?.flightNumber || 'Not available'}" required><br>

                        <!-- Airline Company Input Field -->
                        <label for="airlineCompany">Airline Company</label>
                        <input type="text" id="airlineCompany" name="airlineCompany" value="${tripInfo.flightInfo?.airlineCompany || 'Not available'}" required><br>

                        <!-- Hotel Info Section -->
                        <h4>Hotel Room Info:</h4>
                        
                        <!-- Room Number Input Field -->
                        <label for="roomNumber">Room Number</label>
                        <input type="text" id="roomNumber" name="roomNumber" value="${tripInfo.hotelInfo?.roomNumber || 'Not available'}" required><br>

                        <!-- Hotel Name Input Field -->
                        <label for="hotelName">Hotel Name</label>
                        <input type="text" id="hotelName" name="hotelName" value="${tripInfo.hotelInfo?.hotelName || 'Not available'}" required><br>

                        <!-- Arafa Khayma Section -->
                        <h4>Arafa Khayma:</h4>
                        <label for="arafaKhayma">Arafa Khayma</label>
                        <input type="text" id="arafaKhayma" name="arafaKhayma" value="${tripInfo.arafaKhayma || 'Not available'}" required><br>

                        <!-- Mina Khayma Section -->
                        <h4>Mina Khayma:</h4>
                        <label for="minaKhayma">Mina Khayma</label>
                        <input type="text" id="minaKhayma" name="minaKhayma" value="${tripInfo.minaKhayma || 'Not available'}" required><br>

                        <!-- Submit Button -->
                        <button type="submit">Update Trip Info</button>
                    </form>
                `;

                // Show the form inside the container
                document.getElementById('updateTripInfoContainer').innerHTML = formHTML;

                // Now handle the form submission
                document.getElementById('updateTripInfoForm').addEventListener('submit', function(event) {
                    event.preventDefault();

                    // Collect updated values from the form
                    const seat = document.getElementById('seat').value;
                    const flightNumber = document.getElementById('flightNumber').value;
                    const airlineCompany = document.getElementById('airlineCompany').value;
                    const roomNumber = document.getElementById('roomNumber').value;
                    const hotelName = document.getElementById('hotelName').value;
                    const arafaKhayma = document.getElementById('arafaKhayma').value;
                    const minaKhayma = document.getElementById('minaKhayma').value;

                    // Send updated trip info to the server
                    updateTripInfo(clientId, { seat, flightNumber, airlineCompany }, { roomNumber, hotelName }, arafaKhayma, minaKhayma);
                });
            } else {
                console.error("Failed to fetch trip info", data.message);
            }
        })
        .catch(error => console.error("Error fetching trip info:", error));
}

const updateTripInfo = async (clientId, flightInfo, hotelInfo, arafaKhayma, minaKhayma) => {
    try {
        const response = await fetch(`${backendURL}/updateTripInfo`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                clientId,
                flightInfo,
                hotelInfo,
                arafaKhayma,
                minaKhayma,
            }),
        });

        const data = await response.json();
        
        if (data.success) {
            console.log('Trip info updated successfully');
            alert('Trip info updated successfully');
        } else {
            console.log('Error updating trip info:', data.message);
            alert('Error: ' + data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('An error occurred while updating the trip info.');
    }
};

    // Function to set up client location tracking (for each client)
     function setupClientLocationTracking(client) {
    const checkbox = document.getElementById(`saveLocation-${client._id}`);
    
    if (!checkbox) {
        console.error(`Checkbox with id 'saveLocation-${client._id}' not found.`);
        return;
    }

    // First, check localStorage or any other state to set the initial checkbox state
    const savedLocationTracking = localStorage.getItem(`trackLocation-${client._id}`);
    if (savedLocationTracking === 'true') {
        checkbox.checked = true;  // Set checkbox to checked if the admin enabled tracking
    } else {
        checkbox.checked = false;  // Set checkbox to unchecked if the admin disabled tracking
    }

    // Event listener to handle checkbox state change
    checkbox.addEventListener('change', function () {
        const isChecked = checkbox.checked;
        // Save the checkbox state to localStorage
        localStorage.setItem(`trackLocation-${client._id}`, isChecked.toString());

        // Emit the updated location tracking status to the server
        socket.emit('locationTrackingStatus', {
            clientId: client._id,
            trackLocation: isChecked // Send 'true' or 'false'
        });

        // Log the updated status
        console.log(`Location tracking for client ${client._id} is now: ${isChecked ? 'Enabled' : 'Disabled'}`);
    });
}

});



// Function to show the buttons for 5 seconds when user clicks the image
function showButtonsFor5Seconds(clientItem, iconContainer) {
    // Hide the icon-container (image and status dot)
    iconContainer.classList.add('hidden');

    // Show the buttons
    const buttons = clientItem.querySelectorAll('.action-button');
    buttons.forEach(button => {
        button.classList.remove('hidden'); // Show buttons
    });

    // After 5 seconds, hide the buttons again and show the icon-container (image and status dot)
    setTimeout(() => {
        buttons.forEach(button => {
            button.classList.add('hidden'); // Hide buttons again
        });
        iconContainer.classList.remove('hidden'); // Show the icon-container again (image and status dot)
    }, 5000);
}

socket.on('clientStatusUpdated', (data) => {
        const clientItem = document.getElementById(`client-${data.clientId}`);
        const statusDot = clientItem.querySelector('.status-dot');
        const statusText = clientItem.querySelector('span');

        if (data.status === 'online') {
            statusDot.style.backgroundColor = 'yellow';
        } else {
            statusDot.style.backgroundColor = 'red';
        }
        
    });

    // Function to add End Call and Mute buttons to a specific client in the DOM
function addEndAndMuteButtons(clientId) {
    const clientItem = document.getElementById(`client-${clientId}`);
    const callInProgressClient = document.getElementById("callInProgress")
    if (clientItem) {
     
            const endCallButton = document.getElementById('endCallButton');
          
            endCallButton.onclick = function() {
                // Get the adminId from localStorage
             endCallButton.style.display = "none"
             muteButton.style.display = "none"
                const storedAdminId = localStorage.getItem('adminId');  // Assuming adminId is stored in localStorage
                if (storedAdminId) {
                    endCall(storedAdminId, clientId);  // Pass both storedAdminId and clientId to endCall
                } else {
                    console.error('Missing adminId in localStorage');
                }
            };

            const muteButton = document.getElementById('muteButton');
          
            muteButton.onclick = function() {
                toggleMute(clientId);  // Call the existing toggleMute function to mute/unmute
            };

            // Append buttons to the client item
            callInProgressClient.appendChild(endCallButton);
            callInProgressClient.appendChild(muteButton);
        
    }
}

// Function to handle form submission
document.getElementById('updateClientForm').addEventListener('submit', async function(e) {
    e.preventDefault();

    const clientId = this.getAttribute('data-client-id'); // Get the client ID from the form data attribute
    const gender = document.getElementById('gender').value;
    const firstName = document.getElementById('firstName').value;
    const lastName = document.getElementById('lastName').value;

    const updateData = { gender, firstName, lastName };

    try {
        // Send the PUT request to update client information
        const response = await fetch(`${backendURL}/updateClientInfo/${clientId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}` // Add token for authentication
            },
            body: JSON.stringify(updateData)
        });

        const data = await response.json();
        if (response.ok) {
            alert('Client information updated successfully!');
            console.log(data.client); // The updated client data

            // Hide the update form after successful submission
            document.getElementById('updateClientForm').reset();
            document.getElementById('updateClientForm').style.display = 'none';
        } else {
            alert('Error updating client information');
            console.log(data);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error updating client information');
    }
});
function setupClientLocationTracking(client) {
    const checkbox = document.getElementById(`saveLocation-${client._id}`);

    // Check if the checkbox exists before trying to add an event listener
    if (!checkbox) {
        console.error(`Checkbox with id 'saveLocation-${client._id}' not found.`);
        return;
    }

    // Set the checkbox state based on client age (as per your logic)
    checkbox.checked = client.age > 60;

    // Event listener to handle checkbox state change
    checkbox.addEventListener('change', function () {
        const isChecked = checkbox.checked;

        // Emit the updated location tracking status to the server
        socket.emit('locationTrackingStatus', {
            clientId: client._id,
            trackLocation: isChecked // Send 'true' or 'false'
        });

        console.log(`Location tracking for client ${client._id} is now: ${isChecked ? 'Enabled' : 'Disabled'}`);
    });
}

// add gender no call received 

let healthAlertMarkers = [];

// Function to handle emergency alert and update map
function handleEmergencyAlert(data) {
    console.log('Emergency alert received:', data);
    const { clientId, latitude, longitude, username, securityCode, message } = data;

    // Log the latitude and longitude to see what values are being passed
    console.log('Received emergency alert with coordinates:', { latitude, longitude });

    // Ensure latitude and longitude are valid numbers before creating the marker
    if (typeof latitude === 'number' && !isNaN(latitude) && typeof longitude === 'number' && !isNaN(longitude)) {
        // Display an alert with the emergency information
        alert(`Emergency Alert: ${username} lost!\nCode: ${securityCode}`);

        // Ensure the map is initialized
        if (windowMap) {
            // Create a marker with valid coordinates
            const healthAlertMarker = L.marker([latitude, longitude], {
                icon: L.icon({
                    iconUrl: 'emergency_icon.gif', // Icon for emergency
                    iconSize: [30, 30]
                })
            })
            .addTo(windowMap)
            .bindPopup(`${message}\nUser: ${username} LOST`)
            .openPopup();

            // Store the marker in the array
            healthAlertMarkers.push(healthAlertMarker);
        } else {
            console.error('Map (windowMap) is not initialized!');
        }
    } else {
        // Handle invalid coordinates (fallback to [0, 0])
        console.error('Invalid coordinates received for emergency alert:', { latitude, longitude });

        // Provide fallback coordinates in case of invalid values
        const fallbackCoordinates = [0, 0];  // Use a default location (e.g., [0, 0])
        const healthAlertMarker = L.marker(fallbackCoordinates, {
            icon: L.icon({
                iconUrl: 'emergency_icon.gif',  // Icon for emergency
                iconSize: [30, 30]
            })
        })
        .addTo(windowMap);

        // Bind a popup to indicate invalid location data
        healthAlertMarker.bindPopup('Invalid location data').openPopup();
    }
}

// Listen for emergency alert events from the server
socket.on('emergencyAlertReceived', handleEmergencyAlert);


let safeLocationMarker = null;  // Store the marker for the safe location
const sendSafeLocationBtn = document.getElementById('sendSafeLocationBtn'); // The Send button

// Add event listener to "Safe Location" button
document.getElementById('safeLocationBtn').addEventListener('click', function() {
    if (windowMap) {
        windowMap.on('click', (event) => setSafeLocation(event)); // Pass event explicitly
    }

    // Hide the "Safe Location" button and show the "Send" button
    this.style.display = 'none';
    sendSafeLocationBtn.style.display = 'inline';
});


// Function to handle the map click event and set the safe location
function setSafeLocation(event) {
    // Get the latitude and longitude of the clicked point
    const lat = event.latlng.lat;
    const lng = event.latlng.lng;

    console.log("Admin selected safe location:", lat, lng);

    // If a marker already exists, remove it
    if (safeLocationMarker) {
        windowMap.removeLayer(safeLocationMarker);
    }

    // Add a marker at the clicked location to represent the safe location
    safeLocationMarker = L.marker([lat, lng], { icon: L.icon({
        iconUrl: 'safe-location-icon.png',  // Custom icon for safe location
        iconSize: [25, 25], // Adjust size
        iconAnchor: [12, 25], // Position the icon at the bottom center
        popupAnchor: [0, -25] // Popup anchor above the marker
    }) })
    .addTo(windowMap)
    .bindPopup("Safe Location")
    .openPopup();

    // Update the global safe location
    windowMap.off('click', setSafeLocation);  // Disable further map clicks

    // Show the "Send" button to broadcast the safe location
    sendSafeLocationBtn.style.display = 'block'; 
}

// Add event listener for the "Send Safe Location" button
sendSafeLocationBtn.addEventListener('click', function() {
    // Get the current safe location's latitude and longitude
    const safeLocation = { 
        lat: safeLocationMarker.getLatLng().lat, 
        lng: safeLocationMarker.getLatLng().lng 
    };

   
    socket.emit('sendSafeLocation', { safeLocation });
    console.log("Safe location sent to all clients!");

    // Optionally, reset the map and hide the button again
    sendSafeLocationBtn.style.display = 'none'; // Hide the send button
    document.getElementById('safeLocationBtn').style.display = 'inline'; // Show the set safe location button again
});


// Array to store health alert markers

function handleHealthAlert(data) {
    console.log('health alert received:', data);
    const { clientId, latitude, longitude, username, securityCode, message } = data;

    // Log the latitude and longitude to see what values are being passed
    console.log('Received health alert with coordinates:', { latitude, longitude });

    // Ensure latitude and longitude are valid numbers before creating the marker
    if (typeof latitude === 'number' && !isNaN(latitude) && typeof longitude === 'number' && !isNaN(longitude)) {
        // Display an alert with the emergency information
        alert(`Emergency Alert: ${username} health!\nCode: ${securityCode}`);

        // Ensure the map is initialized
        if (windowMap) {
            // Create a marker with valid coordinates
            const healthAlertMarker = L.marker([latitude, longitude], {
                icon: L.icon({
                    iconUrl: 'emergency_icon.gif', // Icon for emergency
                    iconSize: [30, 30]
                })
            })
            .addTo(windowMap)
            .bindPopup(`${message}\nUser: ${username} health`)
            .openPopup();

            // Store the marker in the array
            healthAlertMarkers.push(healthAlertMarker);
        } else {
            console.error('Map (windowMap) is not initialized!');
        }
    } else {
        // Handle invalid coordinates (fallback to [0, 0])
        console.error('Invalid coordinates received for emergency alert:', { latitude, longitude });

        // Provide fallback coordinates in case of invalid values
        const fallbackCoordinates = [0, 0];  // Use a default location (e.g., [0, 0])
        const healthAlertMarker = L.marker(fallbackCoordinates, {
            icon: L.icon({
                iconUrl: 'emergency_icon.gif',  // Icon for emergency
                iconSize: [30, 30]
            })
        })
        .addTo(windowMap);

        // Bind a popup to indicate invalid location data
        healthAlertMarker.bindPopup('Invalid location data').openPopup();
    }
}

socket.on('healthAlertReceived', handleHealthAlert)


// Function to clear all health alert markers from the map
function clearHealthAlertMarkers() {
    // Iterate over the stored markers and remove them
    healthAlertMarkers.forEach(marker => {
        windowMap.removeLayer(marker); // Remove each marker from the map
    });
    
    // Clear the array holding the markers
    healthAlertMarkers = [];
  
    console.log("Health alert markers cleared from the map.");
}

// Add event listener to the "Clear Health Alerts" button
document.getElementById('clearAlertsBtn').addEventListener('click', clearHealthAlertMarkers);


//////----------------------------------------------------------------------------------------------------------------------------
let currentAlert = null;
let alertTimeout = null;  // Timeout for re-appearing the alert
let alertMarker = null;   // Variable to store the client marker

// Listen for geofence alerts from the server
// Listen for geofence alerts from the server
socket.on('geofenceAlertReceived', (data) => {
    const { username, message, latitude, longitude, securityCode } = data;
    document.getElementById("alert-container").style.display = "block"
    // Display the alert with the username in the custom alert UI
    displayAlert(message, username, latitude, longitude, securityCode);

    // Optionally, show the client's icon on the map
    if (windowMap) {
        if (alertMarker) {
            windowMap.removeLayer(alertMarker);  // Remove previous alert marker if any
        }

        // Create a new marker for the client who is outside the geofence
        alertMarker = L.marker([latitude, longitude], {
            icon: L.icon({
                iconUrl: 'lost.png', // Custom alert icon
                iconSize: [25, 25]
            })
        }).addTo(windowMap)
          .bindPopup(`${message}\nClient: ${username}\nSecurity Code: ${securityCode}`)
          .openPopup();

        console.log(`Geofence alert for ${username}: ${message} at [${latitude}, ${longitude}]`);
    }
});
// Function to display the alert in the custom UI
function displayAlert(message, username, latitude, longitude, securityCode) {
    currentAlert = { message, username, latitude, longitude, securityCode };
    
    // Set the alert message in the UI
    const alertMessageDiv = document.getElementById('alert-message');
    alertMessageDiv.innerHTML = `${message}<br>Client: ${username}<br>Location: [${latitude}, ${longitude}]<br>Security Code: ${securityCode}`;

    // Show the alert and enable the buttons
    document.getElementById('alert-container').style.display = 'block';

    // Clear previous timeout if any
    if (alertTimeout) {
        clearTimeout(alertTimeout);
    }

    // Set a timeout to re-display the alert in 5 minutes if "Not Yet" is clicked
    alertTimeout = setTimeout(() => {
        if (currentAlert) {
            displayAlert(currentAlert.message, currentAlert.username, currentAlert.latitude, currentAlert.longitude, currentAlert.securityCode);
        }
    }, 5 * 60 * 1000);  // 5 minutes
}

// Function to clear the alert when the "Found" button is clicked
function clearGeofenceAlert() {
    document.getElementById('alert-container').style.display = 'none';  // Hide the alert UI
    currentAlert = null;  // Reset the current alert
    if (windowMap && alertMarker) {
        windowMap.removeLayer(alertMarker);  // Remove the marker from the map
        alertMarker = null;  // Reset the marker variable
    }
    // Clear the timeout as the alert is found
    if (alertTimeout) {
        clearTimeout(alertTimeout);
    }
    console.log("Geofence alert cleared.");
}

// Function to keep the alert and re-display it every 5 minutes when "Not Yet" is clicked
function keepAlert() {
    if (currentAlert) {
        displayAlert(currentAlert.message, currentAlert.username, currentAlert.latitude, currentAlert.longitude, currentAlert.securityCode);
    }
}



//-------------------------------------------------------------------
 // Listen for the client status change event
 socket.on('clientStatusChanged', (data) => {
            const { username, securityCode, status } = data;
            const clientStatusList = document.getElementById('client-status-list');

            // Create a new status element or update an existing one
            let clientStatusElement = document.getElementById(`Status of ${username} code ${securityCode}`);

            if (!clientStatusElement) {
                // If the client element doesn't exist, create a new one
                clientStatusElement = document.createElement('div');
                clientStatusElement.id = `Status of ${username} code ${securityCode}`;
                clientStatusList.appendChild(clientStatusElement);
            }

            // Update the status text and color based on the status
            clientStatusElement.textContent = `Status of ${username} is ${status} code ${securityCode}`;
            clientStatusElement.style.color = status === 'online' ? 'green' : 'red';
        });



///// --------------------------------------- location logs for client ---------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    // Initialize the map
    let map = L.map('mymap').setView([39.9800, -86.3815], 13); // Default center

    // Add OpenStreetMap tiles to the map
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    let logs = [];
    let clientMarker;
    let currentAlertType = 'none'; // Default alert type (no alert)
    const markers = [];

    // Define custom icons for alert types
    const painIcon = L.icon({
        iconUrl: 'pain.png', // Replace with your health icon URL
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32]
    });

    const lostIcon = L.icon({
        iconUrl: 'lost.png', // Replace with your lost icon URL
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32]
    });

    const dotIcon = L.icon({
        iconUrl: 'dot.png', // Replace with your default icon URL
        iconSize: [12, 12],
        iconAnchor: [6, 5],
        popupAnchor: [0, -12]
    });

    // Fetch the location logs when form is submitted
    document.getElementById('filter-form').addEventListener('submit', (e) => {
        e.preventDefault(); // Prevent page reload

        const startTime = document.getElementById('startTime').value;
        const endTime = document.getElementById('endTime').value;
        const securityCode = document.getElementById('securityCode').value;

        // Fetch logs from the server
        fetch(`${backendURL}/getLocationLogs?startTime=${startTime}&endTime=${endTime}&securityCode=${securityCode}`)
            .then(response => response.json())
            .then(data => {
                logs = data;
                displayLogsInTable(logs);   // Display logs in table
                plotLocationOnMap(logs);    // Plot locations on the map
            })
            .catch(error => console.error('Error fetching logs:', error));
    });

    // Display logs in a table (only health or lost alertType)
    function displayLogsInTable(logs) {
        const tableBody = document.getElementById('tableBody');
        tableBody.innerHTML = '';  // Clear previous data

        // Filter logs to only show health or lost alertType
        const filteredLogs = logs.filter(log => log.alertType === 'health' || log.alertType === 'lost' || log.alertType === 'low_battery');

        // Display only the filtered logs
        filteredLogs.forEach(log => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${new Date(log.timestamp).toLocaleString()}</td>
                <td>${log.latitude}</td>
                <td>${log.longitude}</td>
                <td>${log.alertType}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    // Plot locations on the map
    function plotLocationOnMap(logs) {
        map.eachLayer(layer => {
            if (layer instanceof L.Marker || layer instanceof L.Polyline) {
                map.removeLayer(layer);
            }
        });

        logs.forEach(log => {
            let iconToUse = dotIcon; // Default icon

            // Change the icon based on alert type
            if (log.alertType === 'health') {
                iconToUse = painIcon; // Health alert icon
            } else if (log.alertType === 'lost') {
                iconToUse = lostIcon; // Lost alert icon
            }

            // Create a marker for each log with the appropriate icon
            L.marker([log.latitude, log.longitude], { icon: iconToUse })
                .addTo(map)
                .bindPopup(`Time: ${new Date(log.timestamp).toLocaleTimeString()}<br>Alert: ${log.alertType}`);
        });

        // Fit the map to the bounds of all markers
        const latlngs = logs.map(log => [log.latitude, log.longitude]);
        const polyline = L.polyline(latlngs, { color: 'blue' }).addTo(map);
        map.fitBounds(polyline.getBounds());
    }

    // Function to animate the client's walking movement
    function animateMovement(logs) {
        let index = 0;
        const totalLogs = logs.length;

        // Before starting, remove all existing markers except for the moving marker
        map.eachLayer(layer => {
            if (layer instanceof L.Marker && layer !== clientMarker) {
                map.removeLayer(layer); // Remove all markers except the moving marker
            }
        });

        // Initial position
        let currentPosition = logs[index];
        if (!clientMarker) {
            clientMarker = L.marker([currentPosition.latitude, currentPosition.longitude], { icon: dotIcon }).addTo(map);
        }

        // Set time interval between movements (for walking simulation)
        const interval = 1000;  // 1 second between each movement

        const animateStep = () => {
            if (index < totalLogs - 1) {
                const nextPosition = logs[index + 1];
                const distance = calculateDistance(currentPosition.latitude, currentPosition.longitude, nextPosition.latitude, nextPosition.longitude);

                // Animate from current position to next position
                let steps = Math.floor(distance / 5);  // Adjust speed here (larger steps = faster animation)
                let stepIndex = 0;

                const moveMarker = setInterval(() => {
                    if (stepIndex < steps) {
                        const lat = currentPosition.latitude + (nextPosition.latitude - currentPosition.latitude) * (stepIndex / steps);
                        const lon = currentPosition.longitude + (nextPosition.longitude - currentPosition.longitude) * (stepIndex / steps);
                        clientMarker.setLatLng([lat, lon]);

                        // Update the marker icon based on the alertType
                        if (nextPosition.alertType === 'health' && currentAlertType !== 'health') {
                            clientMarker.setIcon(painIcon);  // Change to pain icon if alertType is health
                            currentAlertType = 'health';
                        } else if (nextPosition.alertType === 'lost' && currentAlertType !== 'lost') {
                            clientMarker.setIcon(lostIcon);  // Change to lost icon if alertType is lost
                            currentAlertType = 'lost';
                        } else if (nextPosition.alertType === 'none' && currentAlertType !== 'none') {
                            clientMarker.setIcon(dotIcon);  // Change to dot icon if alertType is none
                            currentAlertType = 'none';
                        }

                        // Update time display to match the current position's timestamp
                        const time = new Date(currentPosition.timestamp);
                        document.getElementById('timeDisplay').textContent = `Time: ${time.toLocaleTimeString()}`;

                        stepIndex++;
                    } else {
                        clearInterval(moveMarker);  // End current movement
                        currentPosition = nextPosition;  // Update current position
                        index++;
                        setTimeout(animateStep, interval);  // Move to next step after the interval
                    }
                }, 30); // Change every 30 ms for smooth animation
            } else {
                document.getElementById('timeDisplay').textContent = 'Finished walking simulation!';
            }
        };

        animateStep();  // Start animation
    }

    // Helper function to calculate the distance between two points
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;  // Earth radius in meters
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // Distance in meters
    }

    // Play Button to simulate walking movement on the map
    document.getElementById('playButton').addEventListener('click', () => {
        if (logs.length === 0) {
            alert('No logs to play.');
            return;
        }
        animateMovement(logs);  // Animate the walking simulation
    });
});





const dotIcon = L.icon({
        iconUrl: 'dot.png', // Replace with your default icon URL
        iconSize: [12, 12],
        iconAnchor: [6, 5],
        popupAnchor: [0, -12]
    });
// Function to update the timer and display it
let stream;
let peerConnection;
let me;
let callAccepted = false;
let callEnded = false;
let callerSignal;
let callerId;
let myName = localStorage.getItem('username')
let peerDestroyed = false; // Track if the peer has been destroyed
let callerGender = null

// DOM elements for UI control
const myVideo = document.getElementById('my-video');
const userVideo = document.getElementById('user-video');
const localVideoContainer = document.getElementById('local-video-placeholder');
const remoteVideoContainer = document.getElementById('remote-video-container');
const startCallButton = document.getElementById('start-call');
const endCallButton = document.getElementById('end-call');
const copyIdButton = document.getElementById('copy-id');
const idToCallInput = document.getElementById('idToCall');
const callerContainer = document.getElementById('caller-container');
const answerCallButton = document.getElementById('answer-call');
const callerNameDisplay = document.getElementById('caller-name');
const nameInput = document.getElementById('name');
const theVideoCallLive = document.getElementById('video-call-container')
// New UI elements for post-call
const afterAnswerContainer = document.getElementById('after-answer');
const youLiveWithNameDisplay = document.getElementById('you-live-with-name');
const muteButton = document.getElementById('mute-button');
const cameraButton = document.getElementById('camera-button');

// Get user media only when starting or answering a call
function initializeMedia(isVideoEnabled) {
  return navigator.mediaDevices.getUserMedia({
    video: isVideoEnabled,  // Use video if true, audio-only if false
    audio: true  // Always enable audio
  })
    .then((userStream) => {
      stream = userStream;
      myVideo.srcObject = userStream;
      localVideoContainer.style.display = 'none'; // Hide video icon when stream is available
    })
    .catch((error) => {
      console.error("Camera or microphone not available", error);
    });
}

socket.on("me", (id) => {
  me = id; // Store the user's unique socket ID
});

// Listen for incoming calls
socket.on("callUser", (data) => {
  console.log("Incoming call data:", data);  // Debugging log
  callerSignal = data.signal;
  callerId = data.from;
  callerGender = data.gender;
  callerNameDisplay.textContent = `${data.name} is calling...`;
  answerCallButton.style.display = "block";
  callerContainer.style.display = 'block';

  console.log("Received caller gender:", callerGender); // Debugging log
});


// Start a call to another user
function startCalla(idToCall, name, clientGender) {
    const adminGender = localStorage.getItem('gender');  // Get admin's gender
    theVideoCallLive.style.display='block'
    refreshButton.style.display='none'

  answerCallButton.style.display = 'none';  // Hide the Answer button

  const isVideoEnabled = adminGender === clientGender; // Use video if same gender

// Initialize media (audio and video if same gender, audio only if different gender)
initializeMedia(isVideoEnabled).then(() => {
  const peer = new SimplePeer({
    initiator: true,
    trickle: false,
    stream: stream
  });

    peer.on("signal", (data) => {
      // Emit the call to the server, including the name and signal data
      socket.emit("callUser", {
        userToCall: idToCall,
        signalData: data,
        from: me,
        name: myName
      });
    });

    peer.on("stream", (remoteStream) => {
      userVideo.srcObject = remoteStream;
      remoteVideoContainer.style.display = 'block';
    });

    socket.on("callAccepted", (signal) => {
      callAccepted = true;
      peer.signal(signal);  // Pass the signal to peer
      startCallButton.style.display = 'none';  // Hide start call button for caller
      afterAnswerContainer.style.display = 'block';  // Show post-call UI
      youLiveWithNameDisplay.textContent = `You live with ${name}`;  // Update message for caller
    });

    // Track if the peer has been destroyed
    peer.on('close', () => {
      peerDestroyed = true;
    });

    peerConnection = peer;  // Assign the peer connection to the global variable
  });
}

// Answer an incoming call
function answerCall() {
    theVideoCallLive.style.display='block'
    refreshButton.style.display='none'

    const adminGender = localStorage.getItem('gender');  // Get admin's gender

  const isVideoEnabled = adminGender === callerGender;  // Same gender uses video
  console.log("the gender are the same: ", isVideoEnabled)
console.log("gender of the caller:", callerGender)
  // Initialize media (audio and video if same gender, audio only if different gender)
  initializeMedia(isVideoEnabled).then(() => {
    const peer = new SimplePeer({
      initiator: false,
      trickle: false,
      stream: stream
    });

    peer.on("signal", (data) => {
      socket.emit("answerCall", { signal: data, to: callerId });
    });

    peer.on("stream", (remoteStream) => {
      userVideo.srcObject = remoteStream;
      remoteVideoContainer.style.display = 'block';
      localVideoContainer.style.display = 'block';
    });

    peer.signal(callerSignal);
    peerConnection = peer;

    // Change UI after answering the call
    startCallButton.style.display = 'none';
    callerContainer.style.display = 'none'; // Hide incoming call message
    answerCallButton.style.display = 'none';  // Hide the Answer button
    afterAnswerContainer.style.display = 'block'; // Show the new post-call UI
    youLiveWithNameDisplay.textContent = `You live with ${callerNameDisplay.textContent.replace(' is calling...', '')}`; // Set the new message

    // Show the mute, camera off, and end call buttons for the receiver as well
    socket.emit("callAccepted", { signal: peer.signal, to: callerId });
  });
}

// Mute / Unmute audio
function toggleMute() {
  const audioTrack = stream.getAudioTracks()[0];
  if (audioTrack.enabled) {
    audioTrack.enabled = false;
    muteButton.textContent = 'Unmute'; // Change button text
  } else {
    audioTrack.enabled = true;
    muteButton.textContent = 'Mute'; // Change button text
  }
}

// Turn off / Turn on camera
function toggleCamera() {
  const videoTrack = stream.getVideoTracks()[0];
  if (videoTrack.enabled) {
    videoTrack.enabled = false;
    cameraButton.textContent = 'Turn On Camera'; // Change button text
  } else {
    videoTrack.enabled = true;
    cameraButton.textContent = 'Turn Off Camera'; // Change button text
  }
}

// End the call (Admin Side)
function endCall() {
    refreshButton.style.display='block'
    theVideoCallLive.style.display='none'

  callEnded = true;
  
  if (peerConnection && !peerDestroyed) {
    peerConnection.destroy();  // Destroy the peer connection to prevent further signaling
    peerConnection = null;     // Reset the peerConnection to null
  }

  if (stream) {
    stream.getTracks().forEach(track => track.stop());  // Stop local media tracks
  }

  // Reset UI elements
  remoteVideoContainer.style.display = 'none';
  afterAnswerContainer.style.display = 'none';
  startCallButton.style.display = 'block';  // Show start call button again
  callerContainer.style.display = 'none';  // Hide the caller container
  youLiveWithNameDisplay.textContent = '';  // Reset "You live with" message

  // Reset control buttons (mute, camera)
  muteButton.textContent = 'Mute';
  cameraButton.textContent = 'Turn Off Camera';

  // Emit the end call event to both users
  socket.emit("callEnded", { to: callerId });

  // Reset call status flags
  callAccepted = false;
  callEnded = false;
  location.reload(); // Refresh the page after the call ends
}

// Emit the end call event when the admin ends the call
socket.on('callEnded', () => {
  endCall(); // Ensure the UI resets after the call ends
  location.reload(); // Refresh the page after the call ends
});

// Socket ID update (admin receives client socket ID after reconnect)
socket.on('socketIdUpdated', (data) => {
  console.log('Socket ID updated for user:', data.username, 'New socket ID:', data.socketId);
  // You can store this in a variable or update the UI
  // This ensures that the admin knows the correct socket ID for the client after a reconnect
  storedClientSocketId = data.socketId;
});

// Emit when the admin is ready for a new call (after reconnecting or ending a call)
socket.emit("readyForNewCall", { socketId: socket.id });

// Copy the user's ID to clipboard
function copyToClipboard() {
  navigator.clipboard.writeText(me);
  alert('ID copied to clipboard');
}


socket.emit('readyForNewCall', { socketId: socket.id });

// Get the fullscreen button and video containers
const fullscreenButton = document.getElementById('fullscreenButton');
const videoContainer = document.getElementById('video-call-container');

// Function to enter fullscreen for the video container
function enterFullscreen() {
    if (videoContainer.requestFullscreen) {
        videoContainer.requestFullscreen();
    } else if (videoContainer.mozRequestFullScreen) { // Firefox
        videoContainer.mozRequestFullScreen();
    } else if (videoContainer.webkitRequestFullscreen) { // Chrome, Safari, Opera
        videoContainer.webkitRequestFullscreen();
    } else if (videoContainer.msRequestFullscreen) { // IE/Edge
        videoContainer.msRequestFullscreen();
    }
}

// Function to exit fullscreen
function exitFullscreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.mozCancelFullScreen) { // Firefox
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) { // Chrome, Safari, Opera
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
        document.msExitFullscreen();
    }
}

// Toggle fullscreen for the video container
fullscreenButton.addEventListener('click', function () {
    if (!document.fullscreenElement) {
        // Apply fullscreen styles
        videoContainer.classList.add('fullscreen');
        remoteVideoContainer.classList.add('fullscreen');
        localVideoContainer.classList.add('fullscreen');
        enterFullscreen(); // Enter fullscreen mode
        fullscreenButton.innerHTML = '<i class="fas fa-compress"></i>'; // Change icon to compress
    } else {
        // Remove fullscreen styles
        videoContainer.classList.remove('fullscreen');
        remoteVideoContainer.classList.remove('fullscreen');
        localVideoContainer.classList.remove('fullscreen');
        exitFullscreen(); // Exit fullscreen mode
        fullscreenButton.innerHTML = '<i class="fas fa-expand"></i>'; // Change icon back to expand
    }
});

// Listen for fullscreen changes (exit fullscreen via ESC key or other means)
document.addEventListener('fullscreenchange', function () {
    if (!document.fullscreenElement) {
        // Reset the layout when exiting fullscreen
        videoContainer.classList.remove('fullscreen');
        remoteVideoContainer.classList.remove('fullscreen');
        localVideoContainer.classList.remove('fullscreen');
        fullscreenButton.innerHTML = '<i class="fas fa-expand"></i>';
    }
});




// // done with css and geofence 
// chat


// done with css and geofence 
// Start with chat
const userListContainer = document.querySelector('.user-list');
const firstName = localStorage.getItem("firstName")
const lastName = localStorage.getItem("lastName")
document.getElementById('scroll-left').addEventListener('click', () => {
    userListContainer.scrollBy({
        left: -200,
        behavior: 'smooth',
    });
});

document.getElementById('scroll-right').addEventListener('click', () => {
    userListContainer.scrollBy({
        left: 200,
        behavior: 'smooth',
    });
});

console.log("First Name of the client: ", firstName)
let roomGroup = ''; // To hold the room name dynamically fetched
let loggedInUser = { login: '', firstName: firstName, imageUrl: 'default.jpg' }; // Mock user
let selectedRoom = 'select'; // Default selected room
let messages = {}; // Store messages by room
let reactions = {}; // Store reactions by message ID

// Frontend (client) - Listen for 'update typing' event
socket.on('update typing', (typingUsersList) => {
    const typingIndicator = document.getElementById('typingIndicator');
    const typingMessage = document.getElementById('typingMessage');
    
    // Clear the typing indicator text and hide it initially
    typingMessage.innerHTML = '';
    typingIndicator.style.display = 'none';

    if (typingUsersList.length > 0) {
        typingIndicator.style.display = 'inline-block'; // Show typing indicator
        
        // Create the message for typing users
        if (typingUsersList.length === 1) {
            typingMessage.innerHTML = `${typingUsersList[0]} is typing`;
        } else if (typingUsersList.length === 2) {
            typingMessage.innerHTML = `${typingUsersList[0]} and ${typingUsersList[1]} are typing`;
        } else {
            typingMessage.innerHTML = `${typingUsersList[0]} and ${typingUsersList[1]} are typing, and ${typingUsersList.length - 2} others...`;
        }
    }
});


// Frontend (client) - Handling input and sending 'typing' event

let typingTimeout;
const typingDelay = 1000;  // 1 second delay to stop typing event after typing stops

document.getElementById('inputMessage').addEventListener('input', (e) => {
    console.log('User is typing...');  // Debugging log
    const inputMessage = e.target.value;
    const atPosition = inputMessage.lastIndexOf('@'); // Find the position of '@'

    // If '@' is typed, display the user dropdown
    if (atPosition !== -1) {
        const query = inputMessage.slice(atPosition + 1); // Get the text after '@'

        // Filter the users list based on the query
        const filteredUsers = usersInRoom.filter(user => user.startsWith(query));

        // Display the user dropdown
        showMentionDropdown(filteredUsers);
    } else {
        // Hide the dropdown if '@' is not typed
        hideMentionDropdown();
    }

    clearTimeout(typingTimeout); // Clear any previous typing timeout

    // Emit 'typing' event when the user starts typing
    socket.emit('typing', { 
        room: selectedRoom, 
        username: loggedInUser.login, 
        typing: true 
    });

    // Set a timeout to stop typing event after the delay (1 second)
    typingTimeout = setTimeout(() => {
        socket.emit('typing', { 
            room: selectedRoom, 
            username: loggedInUser.login, 
            typing: false 
        });
    }, typingDelay);
});
// Function to show the mention dropdown with filtered users
function showMentionDropdown(users) {
    const dropdown = document.getElementById('mentionDropdown');
    dropdown.innerHTML = ''; // Clear previous list

    // Create list items for the filtered users
    users.forEach(user => {
        const li = document.createElement('li');
        li.textContent = user;
        li.addEventListener('click', () => {
            // When a user is clicked, insert the mention into the input field
            insertMention(user);
            hideMentionDropdown(); // Hide the dropdown after selection
        });
        dropdown.appendChild(li);
    });

    dropdown.style.display = users.length > 0 ? 'block' : 'none'; // Show the dropdown only if there are users
}


// Function to hide the mention dropdown
function hideMentionDropdown() {
    const dropdown = document.getElementById('mentionDropdown');
    dropdown.style.display = 'none'; // Hide the dropdown
}

// Function to insert the selected mention into the input field
function insertMention(username) {
    const inputMessage = document.getElementById('inputMessage');
    const messageValue = inputMessage.value;

    const atPosition = messageValue.lastIndexOf('@');
    const newMessage = messageValue.slice(0, atPosition) + '@' + username + ' ';
    inputMessage.value = newMessage;

    inputMessage.focus(); // Keep focus on the input field
    inputMessage.selectionStart = inputMessage.selectionEnd = newMessage.length; // Move cursor to the end
}


// Fetch and map clients to their respective rooms
async function getClientsByRoom() {
    const clientsData = await fetchClients();
    const clientsByRoom = {};

    // Group clients by their `groupName`
    clientsData.forEach(client => {
        const room = client.group.groupName;
        if (!clientsByRoom[room]) {
            clientsByRoom[room] = [];
        }
        clientsByRoom[room].push(client);
    });

    return clientsByRoom;
}
        // Populate the room select dropdown with available rooms
async function updateUserListForRoom(roomName) {
    selectedRoom = roomName;
    const clientsByRoom = await getClientsByRoom();
    console.log("Client in userList:", clientsByRoom);

    const userListElement = document.getElementById('userList');
    userListElement.innerHTML = '';  // Clear current list

    if (clientsByRoom[selectedRoom]) {
        clientsByRoom[selectedRoom].forEach(client => {
            const li = document.createElement('li');
            li.id = client.username;

            // Create the dot span element
            const statusDotA = document.createElement('span');
            statusDotA.classList.add('status-dotA');
            
            // Set the color of the dot based on the user's online status
            if (client.status === 'online') {
                statusDotA.style.backgroundColor = '#2ac92a';
            } else {
                statusDotA.style.backgroundColor = '#80808075';
            }

            // Add the status dot next to the username
            const usernameText = document.createElement('span');
            usernameText.textContent = client.username;

            // Append the dot and username to the list item
            li.appendChild(statusDotA);
            li.appendChild(usernameText);
            userListElement.appendChild(li);
        });

        socket.emit('join', selectedRoom, adminName);
        renderMessages(selectedRoom);  
    } else {
        console.log('No users in this room.');
    }
}




// Room selection event listener
document.getElementById('roomSelect').addEventListener('change', async (e) => {
    const newRoom = e.target.value;
    console.log('Room changed to:', newRoom);

    selectedRoom = newRoom;  // Update the selected room
    await updateUserListForRoom(newRoom);  // Update the user list for the new room
});

// Fetch and display available rooms and their users on page load
async function init() {
    const clientsByRoom = await getClientsByRoom();

    // Populate room dropdown
    const roomSelect = document.getElementById('roomSelect');
    roomSelect.innerHTML = '';  // Clear current options

    Object.keys(clientsByRoom).forEach(room => {
        const option = document.createElement('option');
        option.value = room;
        option.textContent = room;  // Use groupName as room name
        roomSelect.appendChild(option);
    });

    // Set default room and display users
    if (Object.keys(clientsByRoom).length > 0) {
        const defaultRoom = Object.keys(clientsByRoom)[0];  // Use the first room as default
        roomSelect.value = defaultRoom;
        await updateUserListForRoom(defaultRoom);  // Display users in the default room
    }
}

// Call the init function to set up the page on load
init();


let hasJoinedRoom = false;

// Prompt for username
function promptForUsername() {
    let username = adminName;
    while (!username) {
        username = prompt("Please enter a username:");
    }
    loggedInUser.login = username;

    // Ensure the room is joined only once
    if (!hasJoinedRoom) {
        socket.emit('join', selectedRoom, username);
        hasJoinedRoom = true;
    }

    document.getElementById('chat-container').style.display = 'none';
}
// Event listener to send a message
document.getElementById('chatForm').addEventListener('submit', (e) => {
    e.preventDefault(); // Prevent form submission

    const inputMessage = document.getElementById('inputMessage').value.trim();
    if (inputMessage) {
        sendMessage(inputMessage);
        document.getElementById('inputMessage').value = ''; // Clear input
    }
});
// Send message to the server
function sendMessage(message) {
    const timestamp = new Date().toISOString();  // Get current timestamp
    const messageData = {
        text: message,
        user: loggedInUser,
        room: selectedRoom,
        timestamp: timestamp // Store the timestamp with the message
    };
    console.log('Sending message:', messageData);  // Debugging log to ensure message is sent
    socket.emit('chat message', messageData);  // Emit the message to the selected room
}
// Frontend (client) - Listen for incoming chat message
socket.on('chat message', (message) => {
    console.log('Received message:', message); // Debugging log to check if messages are received

    // Store the message by room
    if (!messages[message.room]) {
        messages[message.room] = [];  // Create a new array if none exists for the room
    }
    messages[message.room].push(message);
       // Detect mentions in the message
       const mentions = detectMentions(message.text);
    updateMentionCounts(mentions);  // Update mention counts
    notifyMentionedUsers(mentions); // Notify mentioned users

    // Only render messages if they belong to the selected room
    if (message.room === selectedRoom) {
        renderMessages();  // Render messages for the selected room
    }
});

// Maintain a set of user IDs and usernames for each room to prevent duplicates
let displayedUserIds = new Set();
// Create a variable usersInRoom that holds the list of users in the room
let usersInRoom = [];

// Populate usersInRoom with the list of usernames from the DOM
function populateUsersInRoom() {
    const userListElement = document.getElementById('userList');
    const userItems = userListElement.getElementsByTagName('li');

    // Clear the current usersInRoom array
    usersInRoom = [];

    // Iterate over each user item and get the username from the ID of the li element
    Array.from(userItems).forEach(userItem => {
        const username = userItem.id; // Use the 'id' of the li element as the username
        usersInRoom.push(username);
    });

    console.log("Users in room:", usersInRoom); // Debug log
}

// Call populateUsersInRoom when the page loads or when the user list is updated
populateUsersInRoom();


let currentRoom = selectedRoom;  // Store the currently selected room

// Listen for user list updates via Socket.IO
socket.on('update user list', async () => {
    const selectedRoom = document.getElementById('roomSelect').value;
    populateUsersInRoom(); // Update the list of users in the room
    await updateUserListForRoom(selectedRoom);  // Update the user list for the current room
});



// Frontend (client) - Listen for chat history event
socket.on('chat history', (roomMessages) => {
    // console.log('Received chat history for room:', selectedRoom, roomMessages);

    // Store messages for the room
    messages[selectedRoom] = roomMessages;

    // Render the messages for the selected room
    renderMessages(roomMessages);
});


// Handle emoji picker toggle
document.getElementById('emojiPicker').addEventListener('click', () => {
    const emojiPickerContainer = document.getElementById('emojiPickerContainer');
    emojiPickerContainer.style.display = emojiPickerContainer.style.display === 'none' ? 'block' : 'none';
});

// Handle emoji click and insert emoji into the input field
document.querySelectorAll('.emoji').forEach(emoji => {
    emoji.addEventListener('click', (event) => {
        const emojiText = event.target.getAttribute('data-emoji');
        const inputMessage = document.getElementById('inputMessage');
        inputMessage.value += emojiText; // Append emoji to the input field
        inputMessage.focus(); // Ensure focus stays on the input field
        document.getElementById('emojiPickerContainer').style.display = 'none'; // Hide the picker after selection
    });
});

// Room selection logic (updated)
// document.getElementById('roomSelect').addEventListener('change', (e) => {
//     selectedRoom = e.target.value;  // Update the selected room
//     socket.emit('join', selectedRoom);  // Notify the server of the room change
//     renderMessages();  // Render messages for the new selected room
// });
const gender = localStorage.getItem('gender')

// Regular expression to detect @username (only valid usernames)
const mentionRegex = /@([a-zA-Z0-9_]+)/g;

// Function to detect mentions in a message
function detectMentions(messageText) {
    let mentions = [];
    let match;
    while ((match = mentionRegex.exec(messageText)) !== null) {
        mentions.push(match[1]);  // The username mentioned
    }
    return mentions;
}

// Store mention counts
let mentionCounts = {};  // Object to store mention counts

// Function to update mention counts
function updateMentionCounts(mentions) {
    mentions.forEach(mention => {
        // If this mention already exists in mentionCounts, increment its count
        if (mentionCounts[mention]) {
            mentionCounts[mention] += 1;  // Increment mention count
        } else {
            mentionCounts[mention] = 1;   // Set initial mention count to 1 for this user
        }
    });
    updateChatToggleIcon();  // Update the UI after modifying mention counts
}

// Function to notify the mentioned user
function notifyMentionedUsers(mentions) {
    mentions.forEach(mention => {
        if (mention !== loggedInUser.login) {
            socket.emit('mention notification', {
                mentionedUser: mention,
                room: selectedRoom,
                message: `${loggedInUser.login} mentioned you in a message`
            });
        }
    });
}

// Function to update the chat toggle icon with the mention count
function updateChatToggleIcon() {
    const toggleButton = document.getElementById('toggle-chat-btn');
    let mentionCount = mentionCounts[loggedInUser.login] || 0;

    // If there are mentions, show the count
    if (mentionCount > 0) {
      toggleButton.innerHTML = `
    <span class="material-icons">
        <img src="chat.png" style="width: 30px; height: 30px; margin-bottom: -10px;">
        <span id="mentionCount">${mentionCount}</span>
    </span>`;
    } 
}

// Frontend (client) - Listen for the notification event
socket.on('notification', (data) => {
    const { message, room } = data;
    alert(`You were mentioned in room ${room}: ${message}`);
});

function renderMessages() {
    const messageList = document.getElementById('messageList');
    messageList.innerHTML = '';  // Clear existing messages

    // Get messages for the selected room
    const roomMessages = messages[selectedRoom] || [];
    // console.log('Messages for room:', selectedRoom, roomMessages);

    roomMessages.forEach((message) => {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message');

        let displayName = message.user === loggedInUser.login ? 'me' : message.user;

        // Detect mentions in the original message
        let messageContent = message.text;
        const mentions = detectMentions(message.text);

        // Check if the logged-in user is mentioned in the original message
        let isMentionedInOriginal = mentions.includes(loggedInUser.login);

        // Highlight the original message if the logged-in user is mentioned
        mentions.forEach(mention => {
            const mentionLink = `<span class="mention">@${mention}</span>`;
            messageContent = messageContent.replace(`@${mention}`, mentionLink);
        });

        // If the logged-in user is mentioned in the original message, add the highlighted class
        if (isMentionedInOriginal) {
            messageElement.classList.add('mentioned-message');
        }

        messageElement.innerHTML = `
            <div class="message-header">
                <img src="male.png" alt="${message.user}" class="user-image">
                <span class="username">${displayName}</span>
            </div>
            <div class="message-content">${messageContent}</div>
        `;

        // Add "+" button for replies
        const replyButton = document.createElement('button');
        replyButton.classList.add('reply-btn');
        replyButton.innerHTML = '<img src="reply2.png" style="width: 20px; height: 20px;"></span>';
        messageElement.appendChild(replyButton);

        // Event listener to show reply input when "+" button is clicked
        replyButton.addEventListener('click', () => {
            let replyInput = messageElement.querySelector('.reply-input');
            if (!replyInput) {
                replyInput = document.createElement('input');
                replyInput.classList.add('reply-input');
                replyInput.placeholder = 'Write a reply...';
                messageElement.appendChild(replyInput);

                const replySubmitButton = document.createElement('button');
                replySubmitButton.classList.add('reply-submit-btn');
                replySubmitButton.textContent = 'Reply';
                messageElement.appendChild(replySubmitButton);

                replySubmitButton.addEventListener('click', () => {
                    const replyText = replyInput.value.trim();
                    if (replyText) {
                        const replyMessage = {
                            text: replyText,
                            user: loggedInUser,
                            replyTo: message._id,  // Link the reply to the original message ID
                            room: selectedRoom,
                            timestamp: new Date().toISOString(),
                        };

                        socket.emit('chat message', replyMessage);

                        replyInput.value = '';
                        replyInput.remove();
                        replySubmitButton.remove();
                    }
                });
            }
        });

        // Render replies if any
        if (message.replies && message.replies.length > 0) {
            const replyCount = message.replies.length;
            let mentionsUserInReplies = false;

            // Create a container for reply count
            const replyCountElement = document.createElement('div');
            replyCountElement.classList.add('reply-count');
            replyCountElement.textContent = `${replyCount} reply${replyCount > 1 ? 's' : ''}`;

            // Check if any reply mentions the logged-in user
            message.replies.forEach(reply => {
                const replyMentions = detectMentions(reply.text);
                if (replyMentions.includes(loggedInUser.login)) {
                    mentionsUserInReplies = true;
                }
            });

            // If any reply mentions the logged-in user, change the color of replyCountElement
            if (mentionsUserInReplies) {
                replyCountElement.style.color = 'blue';  // Change color (you can customize it)
                replyCountElement.style.background = '#4dff0036'; 

            }

            messageElement.appendChild(replyCountElement);

            // Create a container for replies
            const repliesContainer = document.createElement('div');
            repliesContainer.classList.add('replies-container');
            repliesContainer.style.display = 'none';  // Hide replies initially

            // Add replies
            message.replies.forEach(reply => {
                const replyElement = document.createElement('div');
                replyElement.classList.add('reply');
                replyElement.style.fontSize = '0.8em';  // Smaller size for replies
                replyElement.style.color = 'gray';      // Gray color for replies

                // Check if the reply mentions the logged-in user
                let isMentionedInReply = detectMentions(reply.text).includes(loggedInUser.login);

                // Highlight the reply if it mentions the logged-in user
                if (isMentionedInReply) {
                    replyElement.classList.add('mentioned-message'); // Highlight reply if it mentions the logged-in user
                    
                }

                // Check if the original message is also mentioned and highlight it
                if (isMentionedInOriginal) {
                    messageElement.classList.add('mentioned-message'); // Highlight original message if it mentions the logged-in user
                }

                replyElement.innerHTML = `
                    <div class="reply-header">
                        <span class="username">${reply.user === loggedInUser.login ? 'me' : reply.user}</span>
                        <span class="reply-time">${new Date(reply.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="reply-content">${reply.text}</div>
                `;
                repliesContainer.appendChild(replyElement);
            });

            // Append replies container to message
            messageElement.appendChild(repliesContainer);

            // Toggle replies on reply count click
            replyCountElement.addEventListener('click', () => {
                const isVisible = repliesContainer.style.display === 'block';
                repliesContainer.style.display = isVisible ? 'none' : 'block';  // Toggle visibility
            });
        }

        // Append the message to the list
        messageList.appendChild(messageElement);
    });

    messageList.scrollTop = messageList.scrollHeight;  // Scroll to the bottom
}

// Function to add user to the list
function addUserToList(username) {
    const userListElement = document.getElementById('userList'); // The parent element where users are listed

    // Check if a list item with this username (ID) already exists
    const existingUser = document.getElementById(username);

    if (!existingUser) {
        // If the user doesn't exist, create and append the new list item
        const newUserInRoom = document.createElement('li');
        newUserInRoom.id = username; // Use username as the ID
        newUserInRoom.textContent = username;
        userListElement.appendChild(newUserInRoom);
    } else {
        console.log(`${username} is already in the list, not appending.`);
    }
}

// Function to remove user from the list or change their color to gray if they belong to other rooms
function removeUserFromList(username) {
    const userListElement = document.getElementById('userList'); // The parent element where users are listed

    // Check if the user exists in the list
    const existingUser = document.getElementById(username);

    // Check if the user is still in other rooms
    let isInOtherRooms = false;

    for (const room in usersList) {
        if (usersList[room].includes(username)) {
            isInOtherRooms = true;
            break;
        }
    }

    if (existingUser) {
        if (isInOtherRooms) {
            // Change the user's color to gray if they are still in other rooms
            existingUser.style.color = 'gray';
        } else {
            // Remove the user from the list if they are not in any other room
            userListElement.removeChild(existingUser);
        }
    } else {
        console.log(`${username} is not in the list.`);
    }
}

function toggleChat() {
    const chatContainer = document.getElementById('chat-container');
    const toggleButton = document.getElementById('toggle-chat-btn');

    if (!chatContainer || !toggleButton) {
        console.error("Chat container or toggle button not found!");
        return;
    }

    // Toggle chat visibility and update the button's icon accordingly
    if (chatContainer.style.display === 'none') {
        chatContainer.style.display = 'flex'; // Show the chat container
        mentionCounts[loggedInUser.login] = 0;  // Reset mention counts when opening the chat

        toggleButton.innerHTML = '<span class="material-icons"><img src="minus-icon.png" style="width: 30px; height: 30px; margin-bottom: -6px;"></span>'; // Change icon to close

        console.log(`${loggedInUser.login} has opened the chat and joined the room.`);
        
        // Add user to the list (if not already added)
        addUserToList(loggedInUser.login);

        // Emit join event to the server for the selected room, but only if not already joined
        if (!hasJoinedRoom) {
            socket.emit('userJoinLeave', {
                roomId: selectedRoom,
                message: `${loggedInUser.login} has joined the ${selectedRoom}!`,
                username: loggedInUser.login,
                action: 'join'
            });
            hasJoinedRoom = true; // Set the flag to prevent duplicate joins
        }

    } else {
        chatContainer.style.display = 'none'; // Hide the chat container

        toggleButton.innerHTML = '<span class="material-icons"><img src="chat.png" style="width: 30px; height: 30px; margin-bottom: -10px;"></span>'; // Change icon to chat

        console.log(`${loggedInUser.login} has closed the chat and left the room.`);
        
        // Remove user from the list
        removeUserFromList(loggedInUser.login);

        // Emit leave event to the server for the selected room, but only if the user is currently in the room
        if (hasJoinedRoom) {
            socket.emit('userJoinLeave', {
                roomId: selectedRoom,
                message: `${loggedInUser.login} has left the ${selectedRoom}!`,
                username: loggedInUser.login,
                action: 'leave'
            });
            hasJoinedRoom = false; // Set the flag to prevent duplicate leaves
        }
    }
}


// Listen for color changes when users join or leave
socket.on('colorChange', (data) => {
    const userElement = document.getElementById(data.username);
    if (userElement) {
        if (data.action === 'join') {
            userElement.style.color = 'black'; // User joined, set color to black
        } else if (data.action === 'leave') {
            userElement.style.color = 'gray'; // User left, set color to gray
        }
    }
});
// Listen for user list updates (e.g., when a user joins or leaves the room)
socket.on('updateUserList', async (data) => {
    // Ensure this only updates for the current room
    if (data.roomId === selectedRoom) {
        await updateUserListForRoom(selectedRoom);  // Update the user list for the current room
    }
});


// Listen for system messages (e.g., "user has joined" or "user has left")
socket.on('systemMessage', (data) => {
    const { message, roomId } = data;  // Destructure the incoming data properly
    console.log("message: ", message, "roomId: ", roomId);  // Log the message and roomId for debugging

    // Check if the system message is for the current room
    if (roomId === selectedRoom) {
        // Ensure that the message is a string (it should be based on your server-side logic)
        if (typeof message === 'string') {
            // Push the system message into the room's message array
            messages[selectedRoom].push({ user: 'System', text: message });

            // Re-render the chat to show the system message
            renderMessages();
        } else {
            console.error("Received message is not a string:", message);
        }
    }
});





// Function to add user to the list if they aren't already present
function addUserToList(username) {
    const userListElement = document.getElementById('userList');  // The parent element where users are listed

    // Check if a list item with this username (ID) already exists
    const existingUser = document.getElementById(username);

    if (!existingUser) {
        // If the user doesn't exist, create and append the new list item
        const newUserInRoom = document.createElement('li');
        newUserInRoom.id = username;  // Use username as the ID
        newUserInRoom.textContent = username;
        userListElement.appendChild(newUserInRoom);
    } else {
        console.log(`${username} is already in the list, not appending.`);
    }
}
// Function to remove user from the list
function removeUserFromList(username) {
    const userListElement = document.getElementById('userList');  // The parent element where users are listed

    // Check if a list item with this username (ID) exists
    const existingUser = document.getElementById(username);

    if (existingUser) {
        // If the user exists, remove the list item
        userListElement.removeChild(existingUser);
    } else {
        console.log(`${username} is not in the list.`);
    }
}

// Helper function to send a system message to notify others about user join/leave
function sendSystemMessage(text) {
    const systemMessage = {
        user: 'System',
        text: text,
    };
    // Push the system message to the current room
    messages[selectedRoom].push(systemMessage);
    renderMessages();  // Re-render messages to show the system notification
}
// Call the prompt on page load
promptForUsername();




    </script>
    <script>


document.getElementById('create-room-btn').addEventListener('click', () => {
    document.getElementById('create-room-form').style.display = 'block';
});

// Fetch clients from the backend
async function fetchClients() {
    const adminEmail = localStorage.getItem('email'); // Assuming admin is logged in and email is in localStorage

    try {
        const response = await fetch(`${backendURL}/admin/clients?adminEmail=${encodeURIComponent(adminEmail)}`);
        const data = await response.json();
        if (data.success) {
            return data.clients;  // Array of clients { _id, firstName, lastName }
        } else {
            alert('Failed to fetch clients.');
            return [];
        }
    } catch (error) {
        console.error('Error fetching clients:', error);
        alert('Error fetching clients.');
        return [];
    }
}

// Populate the client dropdown list
async function populateClientList() {
    const clients = await fetchClients();

    const clientSelect = document.getElementById('clientsForRoom');
    clients.forEach(client => {
        const option = document.createElement('option');
        option.value = client._id;
        option.textContent = `${client.firstName} ${client.lastName}`;
        clientSelect.appendChild(option);
    });
}

// Handle adding a client to the room with a key status
function handleAddClientToRoom() {
    const addClientBtn = document.getElementById('add-client-to-room-btn');
    const clientSelect = document.getElementById('clientsForRoom');
    const clientsListElement = document.getElementById('clients-list');
    let clientsInRoom = [];  // Keeps track of clients in the room

    addClientBtn.addEventListener('click', () => {
        const clientId = clientSelect.value;

        if (!clientId) {
            alert('Please select a client');
            return;
        }

        // Fetch the client details to show in the list
        const client = Array.from(clientSelect.options).find(option => option.value === clientId);
        const clientName = client.textContent;

        // Check if the client is already added
        if (clientsInRoom.some(item => item.clientId === clientId)) {
            alert('This client is already added to the room');
            return;
        }

        // Add client to the list with a checkbox for key
        const li = document.createElement('li');
        li.innerHTML = `
            <span>${clientName}</span>
            <label>
                <input type="checkbox" class="key-checkbox" data-client-id="${clientId}" /> Has Key
            </label>
        `;

        clientsInRoom.push({ clientId, hasKey: false });  // Add client without key initially

        clientsListElement.appendChild(li);

        // Enable the key checkbox for only one client at a time
        const keyCheckboxes = document.querySelectorAll('.key-checkbox');
        keyCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                // Ensure only one client has the key at a time
                if (checkbox.checked) {
                    clientsInRoom.forEach(client => {
                        if (client.clientId === checkbox.dataset.clientId) {
                            client.hasKey = true;
                        } else {
                            client.hasKey = false;
                        }
                    });
                }
                updateKeyCheckboxesState();
            });
        });

        updateKeyCheckboxesState();
    });
}

// Handle form submission
document.getElementById('create-room-form').addEventListener('submit', async (event) => {
    event.preventDefault(); // Prevent the default form submission

    const hotelName = document.getElementById('hotelNameCreate').value;
    const roomNumber = document.getElementById('roomNumberCreate').value; // Use room number from the form
    const roomType = document.getElementById('roomType').value;
    const bedNumber = document.getElementById('bedNumber').value;
    const hotelStar = Number(document.getElementById('hotelStar').value); // Ensure this is a number
    const peopleInRoom = document.getElementById('peopleInRoom').value;
    const level = document.getElementById('level').value;
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;

    // Get clients with key info from checkboxes
    const clientsWithKeys = [];
    const clientIds = [];

    document.querySelectorAll('.key-checkbox').forEach(checkbox => {
    const clientId = checkbox.dataset.clientId;  // Get the client ID from the checkbox's data attribute
    const hasKey = checkbox.checked;  // Whether the checkbox is checked (i.e., they have the key)
    clientIds.push(clientId);  // Store just the clientId
    clientsWithKeys.push({ clientId, hasKey });  // Store the clientId with hasKey flag
});
const adminId = localStorage.getItem('adminId');
const requestData = {
    roomNumber,
    bedNumber,
    hotelName,
    hotelStar,
    peopleInRoom,
    level,
    startDate,
    endDate,
    roomType,
    adminId,
    clients: clientsWithKeys,  // Use `clientsWithKeys` here instead of `clientIds` or `clients`
};

    

   

    try {
        const response = await fetch(`${backendURL}/create-room`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData),
        });

        const data = await response.json();

        if (data.success) {
            alert('Room created successfully!');
            fetchRooms();  // Refresh the rooms list
        } else {
            alert('Error creating room');
        }
    } catch (error) {
        console.error('Error creating room:', error);
        alert('Error creating room');
    }
});

// Function to update the key checkbox state
function updateKeyCheckboxesState() {
    const keyCheckboxes = document.querySelectorAll('.key-checkbox');
    
    let checkedCount = 0;
    
    // Count how many checkboxes are checked
    keyCheckboxes.forEach(checkbox => {
        if (checkbox.checked) {
            checkedCount++;
        }
    });

    // If more than one checkbox is checked, uncheck the others
    if (checkedCount > 1) {
        keyCheckboxes.forEach(checkbox => {
            if (checkbox.checked) {
                checkbox.checked = false;
            }
        });
    }
}

// Load client list when the page loads
document.addEventListener('DOMContentLoaded', () => {
    populateClientList();
    handleAddClientToRoom();
});

let debounceTimeout;

document.getElementById('searchInputRoom').addEventListener('input', async (event) => {
    const searchQuery = event.target.value.toLowerCase(); // Get the search query

    // Clear the previous debounce timeout
    clearTimeout(debounceTimeout);

    // Set a new timeout to fetch rooms after the user stops typing for 300ms
    debounceTimeout = setTimeout(() => {
        fetchRooms(searchQuery);
    }, 300);
});
async function fetchRooms(searchQuery = '') {
    const adminId = localStorage.getItem('adminId'); // Get the adminId from localStorage

    if (!adminId) {
        alert('Admin ID is missing');
        return;
    }

    try {
        const response = await fetch(`${backendURL}/get-rooms?adminId=${adminId}`);
        const data = await response.json();

        if (data.success || Array.isArray(data)) { // Check if the data is an array of rooms
            const roomsTableBody = document.getElementById('rooms-table-body');
            roomsTableBody.innerHTML = ''; // Clear existing rows

            // Fetch client details for each room
            for (const room of data) {
                const clientDetails = await fetchClientDetails(room.clients);

                // Filter rooms based on room number or client names matching the search query
                const isRoomMatch = room.roomNumber.toLowerCase().includes(searchQuery);
                const isClientMatch = clientDetails.some(client => 
                    (client.firstName.toLowerCase() + " " + client.lastName.toLowerCase()).includes(searchQuery)
                );

                if (isRoomMatch || isClientMatch) {
                    const clientsList = clientDetails.map(client => {
                        return `<li>${client.firstName} ${client.lastName} (${client.hasKey ? 'Has Key' : 'No Key'})</li>`;
                    }).join('');

                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="text-align: center;">${room.roomNumber.split('-R')[1] || room.roomNumber}</td>
                        <td style="text-align: center;">${room.bedNumber}</td>
                        <td style="text-align: center;">${room.hotelName}</td>
                        <td style="text-align: center;">${room.hotelStar}</td>
                        <td style="text-align: center;">${room.level}</td>
                        <td><button onclick="openUpdateForm('${room._id}')">Update</button></td>
                        <td><button onclick="deleteRoom('${room._id}')">Delete</button></td>
                        <td><ul>${clientsList}</ul></td> <!-- Display the list of clients -->
                    `;
                    roomsTableBody.appendChild(row);
                }
            }
        } else {
            alert('Failed to fetch rooms or no rooms found.');
        }
    } catch (error) {
        console.error('Error fetching rooms:', error);
        alert('Error fetching rooms.');
    }
}

async function fetchClientDetails(clientIds) {
    // Function to fetch client details (assuming you already have this function)
    try {
        const response = await fetch(`${backendURL}/get-clients?clientIds=${clientIds.join(',')}`);
        return await response.json();
    } catch (error) {
        console.error('Error fetching clients:', error);
        return [];
    }
}

async function deleteRoom(roomId) {
    if (confirm('Are you sure you want to delete this room?')) {
        try {
            const response = await fetch(`${backendURL}/delete-room/${roomId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            const data = await response.json();
            if (data.success) {
                alert('Room deleted successfully!');
                fetchRooms();  // Refresh the rooms list
            } else {
                alert('Error deleting room.');
            }
        } catch (error) {
            console.error('Error deleting room:', error);
            alert('Error deleting room.');
        }
    }
}

async function fetchClientDetails(clients) {
    const clientIds = clients
        .map(client => client.clientId)
        .filter(clientId => clientId && clientId.length === 24); // Ensure valid ObjectId format (24 chars)

    if (clientIds.length === 0) {
        console.error('No valid clientIds found.');
        return []; // No valid clientIds to query
    }

    try {
        // Fetch the client details from the server or another source using valid clientIds
        const response = await fetch(`${backendURL}/get-clients-details?clientIds=${clientIds.join(',')}`);
        const data = await response.json();

        if (data.success) {
            // Merge the client details with the hasKey information
            return clients.map(client => {
                const clientDetails = data.clients.find(c => c._id.toString() === client.clientId.toString());
                if (clientDetails) {
                    return {
                        ...client,
                        firstName: clientDetails.firstName,
                        lastName: clientDetails.lastName
                    };
                } else {
                    return client; // If no client details found, just return the original client object
                }
            });
        } else {
            console.error('Failed to fetch client details');
            return [];
        }
    } catch (error) {
        console.error('Error fetching client details:', error);
        return [];
    }
}

async function openUpdateForm(roomId) {
    console.log("Room ID passed to openUpdateForm:", roomId);  // Log to verify the roomId is correct
    roomIdSelected = roomId
    try {
        const response = await fetch(`${backendURL}/get-room/${roomId}`);

        if (response.ok) {
            const roomData = await response.json();

            if (roomData && roomData._id) {
                // Populate the update form with room data
                document.getElementById('update-bedNumber').value = roomData.bedNumber;
                document.getElementById('update-hotelName').value = roomData.hotelName;
                document.getElementById('update-hotelStar').value = roomData.hotelStar;
                document.getElementById('update-peopleInRoom').value = roomData.peopleInRoom;
                document.getElementById('update-level').value = roomData.level;
                document.getElementById('update-startDate').value = new Date(roomData.startDate).toISOString().slice(0, 16);
                document.getElementById('update-endDate').value = new Date(roomData.endDate).toISOString().slice(0, 16);
                document.getElementById('update-roomType').value = roomData.roomType;

                // Populate the clients list
                const clientsListElement = document.getElementById('update-clients-list');
                clientsListElement.innerHTML = ''; // Clear previous client list

                roomData.clients.forEach(client => {
                    const clientData = client.clientId;  // Access client details correctly
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${clientData.firstName} ${clientData.lastName}</span>
                        <label>
                            <input type="checkbox" class="client-checkbox" data-client-id="${clientData._id}" ${client.hasKey ? 'checked' : ''} /> Has Key
                        </label>
                        <button class="remove-client" data-client-id="${clientData._id}">Remove</button>
                    `;
                    clientsListElement.appendChild(li);
                });

                // Handle remove client events
                document.querySelectorAll('.remove-client').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const clientId = e.target.dataset.clientId;
                        await removeClientFromRoom(roomId, clientId);
                    });
                });

                const clients = await fetchClients();  // Get the list of clients
console.log("all clients:", clients);

// Ensure roomData.clientIds is an array of strings
const availableClients = clients.filter(client => 
    !roomData.clientIds.includes(client._id.toString())  // Convert _id to string for comparison
);

console.log("available client in update: ", availableClients);

// Get the client selector dropdown element
const clientSelector = document.getElementById('client-selector');
clientSelector.innerHTML = ''; // Clear existing options

// Add options for available clients
availableClients.forEach(client => {
    const option = document.createElement('option');
    option.value = client._id; // Set the value to the client's _id
    option.textContent = `${client.firstName} ${client.lastName}`; // Display first name and last name
    clientSelector.appendChild(option); // Append the option to the dropdown
});

                  

                // Show the update form
                document.getElementById('update-room-form').style.display = 'block';
            } else {
                alert('Room data is invalid');
            }
        } else {
            alert('Failed to fetch room data');
        }
    } catch (error) {
        console.error('Error fetching room data:', error);
        alert('Error fetching room data');
    }
}


async function removeClientFromRoom(roomId, clientId) {
    try {
        const response = await fetch(`${backendURL}/remove-client-from-room/${roomId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ clientId })
        });

        if (response.ok) {
            alert('Client removed successfully!');
            openUpdateForm(roomId);  // Re-fetch the updated room data
            fetchRoomAndRender();
        } else {
            alert('Failed to remove client');
        }
    } catch (error) {
        console.error('Error removing client:', error);
    }
}

document.getElementById('add-client-button').addEventListener('click', async () => {
    const clientId = document.getElementById('client-selector').value;
    const roomId = roomIdSelected  // Ensure roomId is set before using it

    console.log('Room ID:', roomId);  // Log the roomId to check if it's set
    if (!roomId) {
        alert('Room ID is missing or undefined');
        return;
    }

    if (!clientId) {
        alert('No client selected');
        return;
    }

    try {
        const response = await fetch(`${backendURL}/add-client-to-room/${roomId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ clientId })
        });

        const data = await response.json();
        if (data.success) {
            alert('Client added to room');
            openUpdateForm(roomId); // Re-fetch the room data after addition
        } else {
            alert('Error adding client');
        }
    } catch (error) {
        console.error('Error adding client:', error);
        alert('Error adding client');
    }
});


document.getElementById('update-room').addEventListener('submit', async (event) => {
    event.preventDefault();

    const bedNumber = document.getElementById('update-bedNumber').value;
    const hotelName = document.getElementById('update-hotelName').value;
    const hotelStar = document.getElementById('update-hotelStar').value;
    const peopleInRoom = document.getElementById('update-peopleInRoom').value;
    const level = document.getElementById('update-level').value;
    const startDate = document.getElementById('update-startDate').value;
    const endDate = document.getElementById('update-endDate').value;
    const roomType = document.getElementById('update-roomType').value;

    const clients = [];
    document.querySelectorAll('.client-checkbox').forEach(checkbox => {
        const clientId = checkbox.dataset.clientId;
        const hasKey = checkbox.checked;
        clients.push({ clientId, hasKey });
    });

    const requestData = {
        bedNumber,
        hotelName,
        hotelStar,
        peopleInRoom,
        level,
        startDate,
        endDate,
        roomType,
        clients,
    };

    const roomId = roomIdSelected;

    try {
        const response = await fetch(`${backendURL}/update-room/${roomId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });

        const data = await response.json();
        if (data.success) {
            alert('Room updated successfully!');
            // Optionally close the form or redirect
        } else {
            alert('Error updating room');
        }
    } catch (error) {
        console.error('Error updating room:', error);
        alert('Error updating room.');
    }
});

document.getElementById('room-list-btn').addEventListener('click', async () => {
    const roomsTable = document.getElementById('rooms-list');  // The element holding the room list
    const roomsTableButton = document.getElementById('room-list-btn');
    // Check if the room list is currently displayed
    if (roomsTable.style.display === 'none' || roomsTable.style.display === '') {
        // If not displayed, show the rooms and fetch the data
        roomsTable.style.display = 'block';  // Show the table
        roomsTableButton.innerHTML = 'Hide Room Table'
        // Fetch the rooms (populate the list)
        await fetchRooms();
    } else {
        // If already displayed, hide the rooms
        roomsTable.style.display = 'none';  // Hide the table
    }
});


const hotelId = window.env.HOTELID1
        const roomsTableBody = document.querySelector('#rooms-table-hotel tbody');
        const adminEmail = localStorage.getItem('email'); // This should be dynamically set based on the logged-in admin

        // Fetch rooms for the hotel
        fetch(`${backendURL}/hotel/${hotelId}/rooms`)
            .then(response => response.json())
            .then(rooms => {
                console.log("Room has clients: ", rooms)
                roomsTableBody.innerHTML = ''; // Clear table body before adding new rows
                rooms.forEach(room => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td "text-align: center;">${room.roomNumber.split('-R')[1] || room.roomNumber}</td>
                        <td "text-align: center;">${room.bedNumber}</td>
                        <td "text-align: center;">${room.hotelName}</td>
                        <td "text-align: center;">${room.hotelStar}</td>
                        <td "text-align: center;">${room.level}</td>
                        <td "text-align: center;">
                            <ul id="clients-list-${room._id}">
                                <!-- Clients will be listed here -->
                            </ul>
                        </td>
                        <td>
                            <button class="add-client-btn" data-room-id="${room._id}">Add Client</button>
                        </td>
                    `;
                    roomsTableBody.appendChild(row);

                    // Add event listener to the "Add Client" button
                    const addClientBtn = row.querySelector('.add-client-btn');
                    addClientBtn.addEventListener('click', () => {
                        const roomId = room._id;

                        // Fetch the admin's clients and allow them to select one
                        fetch(`${backendURL}/admin/clients?adminEmail=${adminEmail}`)
                            .then(response => response.json())
                            .then(data => {
                                if (data.success && data.clients.length > 0) {
                                    const clientEmail = prompt("Enter the client's email:");
                                    const client = data.clients.find(c => c.email === clientEmail);

                                    if (client) {
    // Check if room has available beds
    fetch(`${backendURL}/get-room/${roomId}`)
        .then(res => res.json())
        .then(roomData => {
            const currentClientCount = roomData.clients.length;
            const maxBeds = parseInt(roomData.bedNumber, 10);

            if (currentClientCount >= maxBeds) {
                alert('Room is full, check another room');
                return;
            }

            // Proceed to add the client if room is not full
            fetch(`${backendURL}/room/${roomId}/add-client`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ clientId: client._id })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    alert('Client added to the room!');
                    location.reload();
                } else {
                    alert('Failed to add client to room');
                }
            })
            .catch(error => alert('Error adding client.'));
        })
        .catch(error => {
            console.error('Error checking room capacity:', error);
            alert('Failed to check room capacity.');
        });
}
 else {
                                        alert('Client not found or invalid email.');
                                    }
                                } else {
                                    alert('No clients available for this admin.');
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching admin clients:', error);
                                alert('Failed to fetch client data.');
                            });
                            
                    });
                    // Fetch client details for this room
            const clientIds = room.clients.map(client => client.clientId).join(',');
            fetch(`${backendURL}/get-clients-details-hotel?clientIds=${clientIds}`)
                .then(clientResponse => clientResponse.json())
                .then(clientData => {
                    const clientsList = document.getElementById(`clients-list-${room._id}`);
                    room.clients.forEach(client => {
                        const clientDetails = clientData.clients.find(c => c._id.toString() === client.clientId.toString());
                        const clientItem = document.createElement('li');
                        if (clientDetails) {
                            clientItem.innerHTML = `
                                ${clientDetails.firstName} ${clientDetails.lastName} 
                                <input type="checkbox" class="key-status-checkbox" data-room-id="${room._id}" data-client-id="${client.clientId}" ${client.hasKey ? 'checked' : ''}>
                                <button class="remove-client-btn" data-room-id="${room._id}" data-client-id="${client.clientId}">Remove Client</button>
                            `;
                        } else {
                            clientItem.textContent = 'Unknown Client';
                        }
                        clientsList.appendChild(clientItem);

                        // Add event listener to checkbox to update the key status
                        const checkbox = clientItem.querySelector('.key-status-checkbox');
                        checkbox.addEventListener('change', () => {
                            const hasKey = checkbox.checked;
                            updateKeyStatus(room._id, client.clientId, hasKey);
                        });

                        // Add event listener to remove client button
                        const removeBtn = clientItem.querySelector('.remove-client-btn');
                        removeBtn.addEventListener('click', () => {
                            removeClientFromRoom(room._id, client.clientId);
                        });
                    });
                })
                .catch(error => {
                    console.error("Error fetching client details:", error);
                    const clientsList = document.getElementById(`clients-list-${room._id}`);
                    const clientItem = document.createElement('li');
                    clientItem.textContent = 'Unknown Client';
                    clientsList.appendChild(clientItem);
                });
                });
            })
            .catch(error => console.error('Error fetching rooms:', error));
       
        </script>
        

        <script>

            const bookingEmail = "bilalboultif@gmail.com"
          

            // Initialize Stripe
            const strp = window.env.STRIPID
            const stripe = Stripe(`${strp}`);
            const elements = stripe.elements();
    const card = elements.create('card');
    card.mount('#card-element');

    let selectedRooms = [];  // To store selected rooms
    let totalAmount = 0;  // To keep track of the total amount
    let currentRoomIndex = 0; // Track the current position for sliding rooms
    let currentIndex = 0; // Track the current position of rooms
let roomsPerPage = 5; // Number of rooms to display at a time
let roomData = []; // Store the fetched room data
let roomType =  null

            // Function to create Stripe token
            async function createStripeToken() {
    const { token, error } = await stripe.createToken(card);  // Pass the card element to createToken
    if (error) {
        alert('Error with card details: ' + error.message);
        console.error(error);
        return null;
    } else {
        console.log("Stripe Token Created: ", token);  // Check this log to see if token is generated correctly
        return token.id; // Return the generated stripeToken to send to the backend
    }
}

    // Function to fetch room data
// Fetch rooms data from the backend
fetch(`${backendURL}/hotel/${hotelId}/rooms`)
    .then(response => response.json())
    .then(data => {
        roomData = data;  // Store the fetched room data
        renderRooms();     // Render rooms when data is fetched
    })
    .catch(error => console.error('Error fetching rooms:', error));

// Function to render rooms
function renderRooms() {
    const roomListDiv = document.getElementById('room-listA');
    roomListDiv.innerHTML = '';  // Clear existing rooms

    const roomsToDisplay = roomData.slice(currentIndex, currentIndex + roomsPerPage);  // Get rooms to display

    roomsToDisplay.forEach(room => {
        const roomElement = document.createElement('div');
        roomElement.classList.add('room-item');

        // Determine if the room is available or not
        const isAvailable = room.roomStatus === 'available' && room.paymentStatus !== 'paid';
        const isReservedOrPaid = room.roomStatus === 'reserved' || room.paymentStatus === 'paid';

        // Add room details and checkbox (based on availability and payment status)
        roomElement.innerHTML = `
            <div class="room-card">
                <h3 style="text-align: center;">Room Number: ${room.roomNumber.split('-R')[1] || room.roomNumber}</h3>
                <p style="text-align: center;"><strong>Bed Number:</strong> ${room.bedNumber}</p>
                <p style="text-align: center;"><strong>Level (Floor):</strong> ${room.level}</p>
                <p style="text-align: center;"><strong>Room Type:</strong> ${room.roomType}</p>
                <p style="text-align: center;"><strong>Price:</strong> $${room.price}</p>
                <input 
                    type="checkbox" 
                    id="room-${room._id}" 
                    onclick="toggleRoomSelection('${room._id}', ${room.price})" 
                    ${isReservedOrPaid ? 'checked disabled' : ''} 
                    ${isReservedOrPaid ? 'title="Room is reserved or already paid"' : ''} 
                    ${isAvailable ? 'enabled' : 'disabled'} 
                >
                Select this room
            </div>
        `;

        roomListDiv.appendChild(roomElement);
    });
}
// Function to handle sliding (left/right)
function slideRooms(direction) {
    const totalRooms = roomData.length;

    if (direction === 'left') {
        if (currentIndex > 0) {
            currentIndex -= roomsPerPage;  // Move left by the number of rooms per page
        }
    } else if (direction === 'right') {
        if (currentIndex + roomsPerPage < totalRooms) {
            currentIndex += roomsPerPage;  // Move right by the number of rooms per page
        }
    }

    renderRooms();  // Re-render rooms after sliding
}

function getActiveOffer(date) {
    // Fetch current special offers
    return fetch(`${backendURL}/hotel/${hotelId}/special-offers`)
        .then(response => response.json())
        .then(data => {
            const offers = data.specialOffers;
            
            // Check if there are any active offers that apply to the selected date
            return offers.find(offer => {
                const validFrom = new Date(offer.validFrom);
                const validUntil = new Date(offer.validUntil);
                const bookingDate = new Date(date);

                // Return the offer if the booking date is within the offer's validity period
                return bookingDate >= validFrom && bookingDate <= validUntil;
            });
        });
}

function toggleRoomSelection(roomId, roomPrice) {
    const roomIndex = selectedRooms.findIndex(room => room._id === roomId);

    const startDate = document.getElementById('start-date').value;
    const endDate = document.getElementById('end-date').value;

    // Calculate the number of days between start and end dates
    const daysBooked = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 3600 * 24));

    let roomTotal = 0;
    let bookingDates = [];

    // Loop through each day of the booking period to check for eligible discount days
    let currentDate = new Date(startDate);
    while (currentDate <= new Date(endDate)) {
        bookingDates.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1); // Move to the next day
    }

    // Loop through each booking date and check for the offer
    Promise.all(bookingDates.map(date => getActiveOffer(date))).then(offers => {
        offers.forEach((offer, index) => {
            if (offer) {
                // If there's an active offer on the specific day, apply the discount
                const discount = offer.discountPercentage;
                const discountAmount = roomPrice * (discount / 100);
                roomTotal += roomPrice - discountAmount;
                console.log(`Applying ${discount}% discount for ${bookingDates[index].toDateString()}: -$${discountAmount.toFixed(2)}`);
            } else {
                // If no offer, charge full price for that day
                roomTotal += roomPrice;
            }
        });

        // Handle room deselection: properly adjust totalAmount
        if (roomIndex > -1) {
            // Room is being deselected, so subtract its total from totalAmount
            const previousRoomTotal = selectedRooms[roomIndex].totalAmount;
            totalAmount -= previousRoomTotal; // Remove the previous room's total amount
            selectedRooms.splice(roomIndex, 1); // Remove the room from selectedRooms array
        } else {
            // Room is being selected, so add its total to totalAmount
            selectedRooms.push({ _id: roomId, price: roomPrice, startDate, endDate, totalAmount: roomTotal });
            totalAmount += roomTotal; // Add the room's total amount
        }

        // Update the total amount displayed on the page
        const totalAmountDisplay = document.getElementById('total-amount');
        if (totalAmountDisplay) {
            totalAmountDisplay.textContent = `Total: $${totalAmount.toFixed(2)}`;
        }
    });
}


    // Show the payment section after selecting rooms
    const checkoutBtn = document.getElementById('checkout-btn');
    if (checkoutBtn) {
        checkoutBtn.addEventListener('click', () => {
            if (selectedRooms.length === 0) {
                alert('Please select at least one room to reserve!');
                return;
            }

            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;

            // Validate the dates
            if (!startDate || !endDate) {
                alert('Please select both start and end dates.');
                return;
            }

            const paymentSection = document.getElementById('payment-section');
            if (paymentSection) {
                paymentSection.style.display = 'block';
            }
        });
    }

    // Handle payment form submission
    const paymentForm = document.getElementById('payment-form');
    if (paymentForm) {
       paymentForm.addEventListener('submit', async (event) => {
    event.preventDefault();

    const paymentMethod = document.querySelector('input[name="payment-method"]:checked').value;
    let paymentDetails = {};

    // Get the current date for bookingDate (this represents the date the user is making the booking)
    const bookingDate = new Date().toISOString();  // Current date in ISO format


 

    const token = localStorage.getItem('token'); // JWT token for authorization

    // Handle Stripe payment method
    if (paymentMethod === 'card') {
        const stripeToken = await createStripeToken(); // Get Stripe token
        if (!stripeToken) {
            return; // If no token is generated, do not proceed
        }
        paymentDetails = { stripeToken };  // Assign the stripeToken to the paymentDetails object

            // Get selected start and end dates
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const bookingDay = new Date()
            const birthday = '2000-01-01'

            // Prepare booking data to send to the backend
            const bookingData = {
                stripeToken: stripeToken,
                amount: totalAmount * 100,    // Amount in cents (ensure totalAmount is correct)
                rooms: selectedRooms.map(room => ({
                    ...room,  // Existing room data
                    startDate: startDate,  // Add selected start date
                    endDate: endDate,       // Add selected end date
                    roomType: roomType
                })),
                firstName: firstName, // Add first name
                    lastName: lastName,   // Add last name
                    bookingDate: bookingDay.toISOString(), // Add booking date
                paymentMethod: 'card',        // Payment method
                paymentStatus: 'paid',       // Default status before payment is processed
                adminId: adminId,             // Include adminId here
                bookingEmail: bookingEmail ,
                birthday: birthday,
                paymentDetails : paymentDetails
            };

            // Send booking data to backend for payment processing
            fetch(`${backendURL}/hotel/${hotelId}/booking/card`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(bookingData)
            })
            .then(response => response.json())
            .then(data => {
                console.log(data);  // Log the response for inspection
                if (data.success) {
                    // Show success div
                    document.getElementById('payment-success').style.display = 'block';

                    // Check if rooms exist before trying to access them
                    if (data.rooms && data.rooms.length > 0) {
                        const reservedRoomsDetails = document.getElementById('reserved-rooms-details');
                        reservedRoomsDetails.innerHTML = ''; // Clear previous content

                        // Loop through the rooms and display the details
                        data.rooms.forEach(room => {
                            const roomDiv = document.createElement('div');
                            roomDiv.innerHTML = `
                                <p>Room Number: ${room.roomNumber.split('-R')[1] || room.roomNumber}</p>
                                <p>Price: $${room.price}</p>
                                <p>Start Date: ${room.startDate}</p>
                                <p>End Date: ${room.endDate}</p>
                            `;
                            reservedRoomsDetails.appendChild(roomDiv);
                        });

                        // Display the total payment
                        const totalPaymentDiv = document.getElementById('total-payment');
                        totalPaymentDiv.textContent = `Total Payment: $${data.amount / 100}`; // Amount in dollars

                        // Display start and end dates
                        document.getElementById('start-date-display').textContent = startDate;
                        document.getElementById('end-date-display').textContent = endDate;

                        // Update the rooms to reserved status
                        selectedRooms.forEach(room => {
                            room.status = 'reserved';
                        });
                    } else {
                        alert('No rooms were reserved.');
                    }
                } else {
                    alert('Payment failed: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error processing payment: ' + error.message);
            });
        
    } else {
        paymentDetails = {
            message: 'Cash payment selected'
        };
    }
});

    }


     // Show the relevant payment section based on the selected payment method
            document.getElementById('payment-form').addEventListener('change', function(event) {
                const paymentMethod = event.target.value;
                document.getElementById('card-section').style.display = paymentMethod === 'card' ? 'block' : 'none';
                document.getElementById('pay-cash').style.display = paymentMethod === 'cash' ? 'block' : 'none';
            });
</script>
        
    
        
</body>
</html>